============================================================
FILE: ./models/Product.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Schema, model, Document } from "mongoose";
    
    export interface IProduct extends Document {
        name: string;
        description: string;
        price: number;
        stock: number;
        createdAt: Date;
    }
    
    const ProductSchema = new Schema<IProduct>({
        name: { type: String, required: true },
        description: { type: String },
        price: { type: Number, required: true },
        stock: { type: Number, default: 0 },
        createdAt: { type: Date, default: Date.now },
    });
    
    export const Product = model<IProduct>("Product", ProductSchema);

============================================================
FILE: ./models/Cart.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Schema, model, Document, Types } from "mongoose";
    
    export interface ICart extends Document {
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        createdAt: Date; // <--- Adicionado na Interface
    }
    
    const CartSchema = new Schema<ICart>({
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Schema.Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        // Adicionado no Schema para criar a data automaticamente
        createdAt: { type: Date, default: Date.now },
    });
    
    export const Cart = model<ICart>("Cart", CartSchema);

============================================================
FILE: ./models/Order.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Schema, model, Document, Types } from "mongoose";
    
    export interface IOrder extends Document {
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        total: number;
        status: "pending" | "paid" | "shipped" | "completed" | "cancelled";
        createdAt: Date;
    }
    
    const OrderSchema = new Schema<IOrder>({
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        total: { type: Number, required: true },
        status: {
            type: String,
            enum: ["pending", "paid", "shipped", "completed", "cancelled"],
            default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
    });
    
    export const Order = model<IOrder>("Order", OrderSchema);

============================================================
FILE: ./models/User.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Schema, model, Document } from "mongoose";
    
    export interface IUser extends Document {
        name: string;
        email: string;
        passwordHash: string;
        role: "user" | "admin";
        createdAt: Date;
    }
    
    const UserSchema = new Schema<IUser>({
        name: { type: String, required: true },
        email: { type: String, required: true, unique: true },
        passwordHash: { type: String, required: true },
        role: { type: String, enum: ["user", "admin"], default: "user" },
        createdAt: { type: Date, default: Date.now },
    });
    
    export const User = model<IUser>("User", UserSchema);

============================================================
FILE: ./controllers/authController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Request, Response } from "express";
    import bcrypt from "bcrypt";
    import jwt from "jsonwebtoken";
    import { User } from "../models/User";
    
    const JWT_SECRET = process.env.JWT_SECRET || "supersecret";
    
    // Função auxiliar para gerar token
    const generateToken = (user: any) => {
        return jwt.sign({ userId: user._id, role: user.role }, JWT_SECRET, {
            expiresIn: "1h",
        });
    };
    
    export const registerUser = async (req: Request, res: Response) => {
        try {
            const { name, email, password } = req.body;
    
            const existingUser = await User.findOne({ email });
            if (existingUser) {
                return res.status(400).json({ error: "Email já cadastrado" });
            }
    
            const passwordHash = await bcrypt.hash(password, 10);
    
            const newUser = new User({
                name,
                email,
                passwordHash,
                role: "user", // Padrão
            });
    
            await newUser.save();
    
            // CORREÇÃO DO TESTE: Gerar token imediatamente ao registrar
            const token = generateToken(newUser);
    
            // Retornamos o user sem a senha (embora o .select('-passwordHash') na query seja melhor, aqui filtramos manual ou confiamos no toJSON se tiver)
            const userResponse = newUser.toObject();
            // @ts-ignore
            delete userResponse.passwordHash;
    
            res.status(201).json({
                message: "Usuário registrado com sucesso!",
                user: userResponse,
                token, // <--- O teste espera essa propriedade
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao registrar usuário" });
        }
    };
    
    export const loginUser = async (req: Request, res: Response) => {
        try {
            const { email, password } = req.body;
    
            const user = await User.findOne({ email });
    
            // CORREÇÃO DO TESTE: Retornar 401 se usuário não existe
            if (!user) {
                return res.status(401).json({ error: "Credenciais inválidas" });
            }
    
            const isMatch = await bcrypt.compare(password, user.passwordHash);
    
            // CORREÇÃO DO TESTE: Retornar 401 se senha errada
            if (!isMatch) {
                return res.status(401).json({ error: "Credenciais inválidas" });
            }
    
            const token = generateToken(user);
    
            res.json({
                message: "Login realizado com sucesso!",
                token,
                user: {
                    _id: user._id,
                    name: user.name,
                    email: user.email,
                    role: user.role,
                },
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao fazer login" });
        }
    };

============================================================
FILE: ./controllers/adminController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Request, Response } from "express";
    import { User } from "../models/User";
    import { Product } from "../models/Product";
    import { Order } from "../models/Order";
    import { Cart } from "../models/Cart";
    
    export const getStats = async (req: Request, res: Response) => {
        try {
            const { startDate, endDate } = req.query;
            const start = startDate
                ? new Date(startDate as string)
                : new Date("1970-01-01");
            const end = endDate ? new Date(endDate as string) : new Date();
    
            // Usuários
            const users = await User.find({
                createdAt: { $gte: start, $lte: end },
            });
            const totalUsers = users.length;
            const admins = users.filter((u) => u.role === "admin").length;
            const normalUsers = users.filter((u) => u.role === "user").length;
    
            // Produtos
            const products = await Product.find({
                createdAt: { $gte: start, $lte: end },
            });
            const totalProducts = products.length;
    
            // Top Selling (Aggregation)
            const topSelling = await Order.aggregate([
                { $match: { createdAt: { $gte: start, $lte: end } } },
                { $unwind: "$items" },
                {
                    $group: {
                        _id: "$items.productId",
                        sold: { $sum: "$items.quantity" },
                    },
                },
                { $sort: { sold: -1 } },
                { $limit: 5 },
            ]);
    
            // Pedidos
            const orders = await Order.find({
                createdAt: { $gte: start, $lte: end },
            });
            const totalOrders = orders.length;
            const revenueTotal = orders.reduce((acc, o) => acc + o.total, 0);
    
            const ordersByStatus = await Order.aggregate([
                { $match: { createdAt: { $gte: start, $lte: end } } },
                { $group: { _id: "$status", count: { $sum: 1 } } },
            ]);
    
            // Carrinhos
            const carts = await Cart.find({
                createdAt: { $gte: start, $lte: end },
            });
            const avgItems =
                carts.length > 0
                    ? carts.reduce((acc, c) => acc + c.items.length, 0) /
                      carts.length
                    : 0;
            const avgTicket = totalOrders > 0 ? revenueTotal / totalOrders : 0;
            const conversionRate =
                carts.length > 0 ? totalOrders / carts.length : 0;
    
            res.json({
                period: { start, end },
                users: { total: totalUsers, admins, users: normalUsers },
                products: { total: totalProducts, topSelling },
                orders: {
                    total: totalOrders,
                    revenueTotal,
                    avgTicket,
                    byStatus: ordersByStatus,
                },
                carts: { avgItems, conversionRate },
            });
        } catch (error) {
            res.status(500).json({
                error: "Erro ao gerar estatísticas consolidadas",
            });
        }
    };

============================================================
FILE: ./controllers/orderController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Response } from "express";
    import { AuthRequest } from "../middleware/authMiddleware";
    import { Order } from "../models/Order";
    import { Cart } from "../models/Cart";
    
    export const checkout = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
    
            const cart = await Cart.findOne({ userId: req.user.userId });
            if (!cart || cart.items.length === 0) {
                return res.status(400).json({ error: "Carrinho vazio" });
            }
    
            const total = cart.items.reduce((acc: number, item: any) => {
                const price = req.body.prices?.[item.productId] || 0;
                return acc + price * item.quantity;
            }, 0);
    
            const newOrder = new Order({
                userId: req.user.userId,
                items: cart.items,
                total,
                status: "pending",
            });
    
            await newOrder.save();
    
            cart.items = [];
            await cart.save();
    
            res.status(201).json({
                message: "Pedido criado a partir do carrinho!",
                order: newOrder,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao finalizar checkout" });
        }
    };
    
    export const createOrder = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const { items, total } = req.body;
    
            const newOrder = new Order({
                userId: req.user.userId,
                items,
                total,
                status: "pending",
            });
            await newOrder.save();
            res.status(201).json({
                message: "Pedido criado com sucesso!",
                order: newOrder,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao criar pedido" });
        }
    };
    
    export const getMyOrders = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const orders = await Order.find({ userId: req.user.userId });
            res.json(orders);
        } catch (error) {
            res.status(500).json({ error: "Erro ao listar pedidos" });
        }
    };
    
    export const getAllOrders = async (req: AuthRequest, res: Response) => {
        try {
            const orders = await Order.find();
            res.json(orders);
        } catch (error) {
            res.status(500).json({ error: "Erro ao listar todos os pedidos" });
        }
    };
    
    export const updateOrderStatus = async (req: AuthRequest, res: Response) => {
        try {
            const { id } = req.params;
            const { status } = req.body;
            const updatedOrder = await Order.findByIdAndUpdate(
                id,
                { status },
                { new: true },
            );
    
            if (!updatedOrder)
                return res.status(404).json({ error: "Pedido não encontrado" });
    
            res.json({
                message: "Status atualizado com sucesso!",
                order: updatedOrder,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao atualizar pedido" });
        }
    };

============================================================
FILE: ./controllers/cartController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Response } from "express";
    import { AuthRequest } from "../middleware/authMiddleware";
    import { Cart } from "../models/Cart";
    
    export const getCart = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const cart = await Cart.findOne({ userId: req.user.userId });
            res.json(cart || { items: [] });
        } catch (error) {
            res.status(500).json({ error: "Erro ao buscar carrinho" });
        }
    };
    
    export const addToCart = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const { productId, quantity } = req.body;
    
            let cart = await Cart.findOne({ userId: req.user.userId });
            if (!cart) {
                cart = new Cart({ userId: req.user.userId, items: [] });
            }
    
            const existingItem = cart.items.find(
                (item) => item.productId.toString() === productId,
            );
            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                cart.items.push({ productId, quantity });
            }
    
            await cart.save();
            res.json({ message: "Item adicionado ao carrinho", cart });
        } catch (error) {
            res.status(500).json({ error: "Erro ao adicionar item" });
        }
    };
    
    export const removeFromCart = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const { productId } = req.body;
    
            const cart = await Cart.findOne({ userId: req.user.userId });
            if (!cart)
                return res.status(404).json({ error: "Carrinho não encontrado" });
    
            cart.items = cart.items.filter(
                (item) => item.productId.toString() !== productId,
            );
            await cart.save();
    
            res.json({ message: "Item removido do carrinho", cart });
        } catch (error) {
            res.status(500).json({ error: "Erro ao remover item" });
        }
    };
    
    export const clearCart = async (req: AuthRequest, res: Response) => {
        try {
            if (!req.user?.userId)
                return res.status(401).json({ error: "Usuário não autenticado" });
            const cart = await Cart.findOne({ userId: req.user.userId });
            if (!cart)
                return res.status(404).json({ error: "Carrinho não encontrado" });
    
            cart.items = [];
            await cart.save();
            res.json({ message: "Carrinho limpo com sucesso", cart });
        } catch (error) {
            res.status(500).json({ error: "Erro ao limpar carrinho" });
        }
    };

============================================================
FILE: ./controllers/userController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Request, Response } from "express";
    import { User } from "../models/User";
    
    export const getAllUsers = async (req: Request, res: Response) => {
        try {
            const users = await User.find().select("-passwordHash");
            res.json(users);
        } catch (error) {
            res.status(500).json({ error: "Erro ao listar usuários" });
        }
    };
    
    export const getUserById = async (req: Request, res: Response) => {
        try {
            const user = await User.findById(req.params.id).select("-passwordHash");
            if (!user)
                return res.status(404).json({ error: "Usuário não encontrado" });
            res.json(user);
        } catch (error) {
            res.status(500).json({ error: "Erro ao buscar usuário" });
        }
    };
    
    export const updateUser = async (req: Request, res: Response) => {
        try {
            const updatedUser = await User.findByIdAndUpdate(
                req.params.id,
                req.body,
                { new: true },
            ).select("-passwordHash");
            if (!updatedUser)
                return res.status(404).json({ error: "Usuário não encontrado" });
            res.json({
                message: "Usuário atualizado com sucesso!",
                user: updatedUser,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao atualizar usuário" });
        }
    };
    
    export const deleteUser = async (req: Request, res: Response) => {
        try {
            const deletedUser = await User.findByIdAndDelete(req.params.id);
            if (!deletedUser)
                return res.status(404).json({ error: "Usuário não encontrado" });
            res.json({ message: "Usuário removido com sucesso!" });
        } catch (error) {
            res.status(500).json({ error: "Erro ao remover usuário" });
        }
    };

============================================================
FILE: ./controllers/productController.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Request, Response } from "express";
    import { Product } from "../models/Product";
    
    // Lógica para criar produto
    export const createProduct = async (req: Request, res: Response) => {
        try {
            const { name, description, price, stock } = req.body;
            // Validação básica se quiser adicionar
            if (!name || !price) {
                return res
                    .status(400)
                    .json({ error: "Nome e preço são obrigatórios" });
            }
    
            const newProduct = new Product({ name, description, price, stock });
            await newProduct.save();
            res.status(201).json({
                message: "Produto criado com sucesso!",
                product: newProduct,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao criar produto" });
        }
    };
    
    // Lógica para listar produtos
    export const getAllProducts = async (req: Request, res: Response) => {
        try {
            const products = await Product.find();
            res.json(products);
        } catch (error) {
            res.status(500).json({ error: "Erro ao listar produtos" });
        }
    };
    
    // Lógica para atualizar produto
    export const updateProduct = async (req: Request, res: Response) => {
        try {
            const { id } = req.params;
            const updatedProduct = await Product.findByIdAndUpdate(id, req.body, {
                new: true,
            });
            if (!updatedProduct) {
                return res.status(404).json({ error: "Produto não encontrado" });
            }
            res.json({
                message: "Produto atualizado com sucesso!",
                product: updatedProduct,
            });
        } catch (error) {
            res.status(500).json({ error: "Erro ao atualizar produto" });
        }
    };
    
    // Lógica para deletar produto
    export const deleteProduct = async (req: Request, res: Response) => {
        try {
            const { id } = req.params;
            const deletedProduct = await Product.findByIdAndDelete(id);
            if (!deletedProduct) {
                return res.status(404).json({ error: "Produto não encontrado" });
            }
            res.json({ message: "Produto removido com sucesso!" });
        } catch (error) {
            res.status(500).json({ error: "Erro ao remover produto" });
        }
    };

============================================================
FILE: ./server.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import mongoose from "mongoose";
    import dotenv from "dotenv";
    import app from "./app";
    
    dotenv.config();
    
    const PORT = process.env.PORT || 4000;
    
    mongoose
        .connect(process.env.MONGO_URI as string)
        .then(() => {
            console.log("Conectado ao MongoDB Atlas");
            app.listen(PORT, () => {
                console.log(`Servidor rodando na porta ${PORT}`);
            });
        })
        .catch((err) => {
            console.error("Erro ao conectar ao MongoDB:", err);
        });

============================================================
FILE: ./app.ts
LAST_MODIFIED: 2025-12-14 18:13:31
============================================================

    import express from "express";
    import cors from "cors";
    import authRoutes from "./routes/authRoutes";
    import cartRoutes from "./routes/cartRoutes";
    import productRoutes from "./routes/productRoutes";
    import adminRoutes from "./routes/adminRoutes";
    import userRoutes from "./routes/userRoutes";
    import orderRoutes from "./routes/orderRoutes";
    
    const app = express();
    
    // Middlewares
    app.use(cors());
    app.use(express.json());
    
    app.use("/api/auth", authRoutes);
    app.use("/api/cart", cartRoutes);
    app.use("/api/products", productRoutes);
    app.use("/api/users", userRoutes);
    app.use("/api/orders", orderRoutes);
    app.use("/api/admin", adminRoutes);
    
    export default app;

============================================================
FILE: ./routes/cartRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { authenticate } from "../middleware/authMiddleware";
    import {
        getCart,
        addToCart,
        removeFromCart,
        clearCart,
    } from "../controllers/cartController";
    
    const router = Router();
    
    router.get("/", authenticate, getCart);
    router.post("/add", authenticate, addToCart);
    router.post("/remove", authenticate, removeFromCart);
    router.post("/clear", authenticate, clearCart);
    
    export default router;

============================================================
FILE: ./routes/userRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { authenticate } from "../middleware/authMiddleware";
    import { isAdmin } from "../middleware/isAdmin";
    import {
        getAllUsers,
        getUserById,
        updateUser,
        deleteUser,
    } from "../controllers/userController";
    
    const router = Router();
    
    // Todas as rotas de manipulação de usuários exigem Admin neste design
    router.get("/", authenticate, isAdmin, getAllUsers);
    router.get("/:id", authenticate, isAdmin, getUserById);
    router.put("/:id", authenticate, isAdmin, updateUser);
    router.delete("/:id", authenticate, isAdmin, deleteUser);
    
    export default router;

============================================================
FILE: ./routes/authRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { registerUser, loginUser } from "../controllers/authController";
    
    const router = Router();
    
    router.post("/register", registerUser);
    router.post("/login", loginUser);
    
    export default router;
============================================================
FILE: ./routes/adminRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { authenticate } from "../middleware/authMiddleware";
    import { isAdmin } from "../middleware/isAdmin";
    import { getStats } from "../controllers/adminController";
    
    const router = Router();
    
    router.get("/stats", authenticate, isAdmin, getStats);
    
    export default router;

============================================================
FILE: ./routes/orderRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { authenticate } from "../middleware/authMiddleware";
    import { isAdmin } from "../middleware/isAdmin";
    import {
        checkout,
        createOrder,
        getMyOrders,
        getAllOrders,
        updateOrderStatus,
    } from "../controllers/orderController";
    
    const router = Router();
    
    router.post("/checkout", authenticate, checkout);
    router.post("/", authenticate, createOrder);
    router.get("/my", authenticate, getMyOrders);
    
    // Rotas Admin
    router.get("/", authenticate, isAdmin, getAllOrders);
    router.put("/:id", authenticate, isAdmin, updateOrderStatus);
    
    export default router;

============================================================
FILE: ./routes/productRoutes.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Router } from "express";
    import { authenticate } from "../middleware/authMiddleware";
    import { isAdmin } from "../middleware/isAdmin";
    import {
        createProduct,
        getAllProducts,
        updateProduct,
        deleteProduct,
    } from "../controllers/productController";
    
    const router = Router();
    
    // Rotas Públicas
    router.get("/", getAllProducts);
    
    // Rotas Protegidas (Admin)
    router.post("/", authenticate, isAdmin, createProduct);
    router.put("/:id", authenticate, isAdmin, updateProduct);
    router.delete("/:id", authenticate, isAdmin, deleteProduct);
    
    export default router;

============================================================
FILE: ./middleware/authMiddleware.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Request, Response, NextFunction } from "express";
    import jwt, { JwtPayload } from "jsonwebtoken";
    
    const JWT_SECRET = process.env.JWT_SECRET || "supersecret";
    
    export interface AuthRequest extends Request {
        user?: { userId: string; role: string };
    }
    
    interface TokenPayload extends JwtPayload {
        userId: string;
        role: string;
    }
    
    export const authenticate = (
        req: AuthRequest,
        res: Response,
        next: NextFunction,
    ) => {
        const authHeader = req.headers.authorization;
    
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
            return res.status(401).json({ error: "Token não fornecido" });
        }
    
        const token = authHeader.split(" ")[1];
    
        if (!token) {
            return res.status(401).json({ error: "Token não fornecido" });
        }
    
        try {
            const decoded = jwt.verify(
                token,
                JWT_SECRET,
            ) as unknown as TokenPayload;
            req.user = {
                userId: decoded.userId,
                role: decoded.role,
            };
            next();
        } catch (error) {
            return res.status(401).json({ error: "Token inválido ou expirado" });
        }
    };

============================================================
FILE: ./middleware/isAdmin.ts
LAST_MODIFIED: 2025-12-11 14:39:36
============================================================

    import { Response, NextFunction } from "express";
    import { AuthRequest } from "./authMiddleware";
    
    export const isAdmin = (
        req: AuthRequest,
        res: Response,
        next: NextFunction,
    ) => {
        if (!req.user) {
            return res.status(401).json({ error: "Usuário não autenticado" });
        }
    
        if (req.user.role !== "admin") {
            return res
                .status(403)
                .json({ error: "Acesso negado: apenas administradores" });
        }
    
        next();
    };

