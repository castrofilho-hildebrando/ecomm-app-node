============================================================
FILE: ./src/infra/repositories/MongoProductRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Product } from "../models/Product"
    
    export class MongoProductRepository {
        async findById(id: string) {
            const product = await Product.findById(id)
            if (!product) return null
            return {
                id: product._id.toString(),
                _id: product._id.toString(),
                name: product.name,
                price: product.price,
                stock: product.stock,
                description: product.description,
            }
        }
    
        async findByIds(ids: string[]) {
            const products = await Product.find({ _id: { $in: ids } })
            return products.map(p => ({
                id: p._id.toString(),
                _id: p._id.toString(),
                name: p.name,
                price: p.price,
                stock: p.stock,
                description: p.description,
            }))
        }
    
        async decrementStock(productId: string, quantity: number): Promise<void> {
            await Product.updateOne({ _id: productId }, { $inc: { stock: -quantity } })
        }
    
        async findAll() {
            const products = await Product.find()
            return products.map(p => ({
                id: p._id.toString(),
                _id: p._id.toString(),
                name: p.name,
                price: p.price,
                stock: p.stock,
                description: p.description,
            }))
        }
    
        async create(data: { name: string; price: number; stock?: number; description?: string }) {
            const created = await Product.create({
                name: data.name,
                price: data.price,
                stock: data.stock ?? 0,
                description: data.description ?? "",
            })
            return {
                _id: created._id.toString(),
                name: created.name,
                price: created.price,
                stock: created.stock,
                description: created.description,
            }
        }
    
        async update(id: string, data: { name?: string; price?: number; stock?: number; description?: string }) {
            const updated = await Product.findByIdAndUpdate(id, data, { new: true })
            if (!updated) return null
            return {
                _id: updated._id.toString(),
                name: updated.name,
                price: updated.price,
                stock: updated.stock,
                description: updated.description,
            }
        }
    
        async delete(id: string) {
            const res = await Product.findByIdAndDelete(id)
            return !!res
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoCartRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CartRepository } from "../../application/ports/CartRepository"
    import { Cart } from "../models/Cart"
    
    export class MongoCartRepository implements CartRepository {
    
        async findByUserId(userId: string) {
    
            const cart = await Cart.findOne({ userId }).lean()
    
            if (!cart) {
                return null
            }
    
            return {
                userId: cart.userId.toString(),
                items: cart.items.map(item => ({
                    productId: item.productId.toString(),
                    quantity: item.quantity,
                })),
            }
        }
    
        async addItem(userId: string, productId: string, quantity: number) {
    
            await Cart.updateOne(
                { userId, "items.productId": productId },
                { $inc: { "items.$.quantity": quantity } }
            )
    
            await Cart.updateOne(
                { userId, "items.productId": { $ne: productId } },
                { $push: { items: { productId, quantity } } },
                { upsert: true }
            )
        }
    
        async removeItem(userId: string, productId: string) {
            await Cart.updateOne(
                { userId },
                { $pull: { items: { productId } } }
            )
        }
    
        async clear(userId: string) {
            await Cart.updateOne(
                { userId },
                { $set: { items: [] } }
            )
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoOutboxRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Outbox } from "../models/Outbox"
    import { OutboxRepository } from "../../application/ports/OutboxRepository"
    import { ApplicationEvent } from "../../application/events/ApplicationEvent"
    
    export class MongoOutboxRepository implements OutboxRepository {
    
        async save(event: ApplicationEvent): Promise<void> {
    
            await Outbox.create({
                name: event.name,
                payload: event.payload,
                occurredAt: event.occurredAt,
                processed: false
            })
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoOrderRepository.ts
LAST_MODIFIED: 2025-12-29 16:20:20
============================================================

    import { Order } from "../models/Order"
    import { OrderRepository } from "../../application/ports/OrderRepository"
    
    export class MongoOrderRepository implements OrderRepository {
    
        async save(order: any): Promise<void> {
            await Order.create(order)
        }
    
        async create(order: any): Promise<any> {
            const newOrder = new Order(order)
            await newOrder.save()
    
            return {
                id: newOrder._id.toString(),
                userId: newOrder.userId.toString(),
                items: newOrder.items,
                total: newOrder.total,
                status: newOrder.status,
                createdAt: newOrder.createdAt,
            }
        }
    
        async findByUserId(userId: string) {
            const orders = await Order.find({ userId })
            return orders.map(order => ({
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }))
        }
    
        async findById(id: string) {
            const order = await Order.findById(id)
            if (!order) return null
            return {
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }
        }
    
        async updateStatus(id: string, status: string) {
            const order = await Order.findByIdAndUpdate(id, { status }, { new: true })
            if (!order) return null
            return {
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }
        }
    
        async findAll() {
            const orders = await Order.find()
            return orders.map(o => ({
                id: o._id.toString(),
                userId: o.userId.toString(),
                items: o.items,
                total: o.total,
                status: o.status,
                createdAt: o.createdAt,
            }))
        }
    }
============================================================
FILE: ./src/infra/eventBus.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { EventBus } from "../domain/events/EventBus"
    import { OrderCreatedEvent } from "../domain/events/OrderCreatedEvent"
    import { SendOrderEmailHandler } from "../application/handlers/SendOrderEmailHandler"
    import { UpdateSalesMetricsHandler } from "../application/handlers/UpdateSalesMetricsHandler"
    
    export const eventBus = new EventBus()
    
    // wiring
    eventBus.subscribe(
    
        OrderCreatedEvent,
        new SendOrderEmailHandler()
    )
    
    eventBus.subscribe(
    
        OrderCreatedEvent,
        new UpdateSalesMetricsHandler()
    )

============================================================
FILE: ./src/infra/models/Outbox.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Schema, model } from "mongoose"
    
    const OutboxSchema = new Schema(
        {
            name: {
                type: String,
                required: true,
            },
    
            payload: {
                type: Schema.Types.Mixed,
                required: true,
            },
    
            occurredAt: {
                type: Date,
                required: true,
            },
    
            processed: {
                type: Boolean,
                required: true,
                default: false,
            },
    
            processedAt: {
                type: Date,
                required: false,
            },
        },
        {
            timestamps: true,
        }
    )
    
    export const Outbox = model("Outbox", OutboxSchema)

============================================================
FILE: ./src/infra/models/Address.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose, { Document, Schema } from "mongoose"
    
    // 1. Defini√ß√£o da Interface
    export interface IAddress extends Document {
        userId: mongoose.Types.ObjectId;
        street: string;
        city: string;
        state: string;
        zipCode: string;
        country: string;
        isDefault: boolean;
    }
    
    // 2. Defini√ß√£o do Schema
    const AddressSchema: Schema = new Schema({
        // Refer√™ncia ao usu√°rio
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
        
        street: { type: String, required: true },
        city: { type: String, required: true },
        state: { type: String, required: true },
        zipCode: { type: String, required: true },
        country: { type: String, default: "Brazil" },
        
        // Se este √© o endere√ßo padr√£o do usu√°rio
        isDefault: { type: Boolean, default: false },
    }, {
        timestamps: true 
    })
    
    // 3. Exporta√ß√£o do Modelo
    export const Address = mongoose.model<IAddress>("Address", AddressSchema)
============================================================
FILE: ./src/infra/models/Product.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import mongoose, { Schema, Document } from "mongoose"
    
    export interface IProduct extends Document {
      name: string;
      price: number;
      stock: number;
      description?: string;
    }
    
    const productSchema = new Schema<IProduct>(
        {
            name: { type: String, required: true },
            price: { type: Number, required: true },
            stock: { type: Number, default: 0 },
            description: { type: String, default: "" },
        },
        { timestamps: true }
    )
    
    // üîπ Mongoose sempre cria o campo _id automaticamente
    export const Product = mongoose.model<IProduct>("Product", productSchema)

============================================================
FILE: ./src/infra/models/Cart.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document, Types } from "mongoose"
    
    export interface ICart extends Document {
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        createdAt: Date;
    }
    
    const CartSchema = new Schema<ICart>({
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Schema.Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        // Adicionado no Schema para criar a data automaticamente
        createdAt: { type: Date, default: Date.now },
    })
    
    export const Cart = model<ICart>("Cart", CartSchema)

============================================================
FILE: ./src/infra/models/Order.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document, Types } from "mongoose"
    
    export interface IOrder extends Document {
    
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        total: number;
        status: "pending" | "paid" | "shipped" | "completed" | "cancelled";
        createdAt: Date;
    }
    
    const OrderSchema = new Schema<IOrder>({
    
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        total: { type: Number, required: true },
        status: {
            type: String,
            enum: ["pending", "paid", "shipped", "completed", "cancelled"],
            default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
    })
    
    export const Order = model<IOrder>("Order", OrderSchema)

============================================================
FILE: ./src/infra/models/User.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document } from "mongoose"
    
    export interface IUser extends Document {
        name: string;
        email: string;
        passwordHash: string;
        role: "user" | "admin";
        createdAt: Date;
    }
    
    const UserSchema = new Schema<IUser>({
        name: { type: String, required: true },
        email: { type: String, required: true, unique: true },
        passwordHash: { type: String, select: false, required: true },
        role: { type: String, enum: ["user", "admin"], default: "user" },
        createdAt: { type: Date, default: Date.now },
    })
    
    export const User = model<IUser>("User", UserSchema)

============================================================
FILE: ./src/infra/factories/getCartFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:15
============================================================

    import { GetCartUseCase } from "../../application/usecases/GetCartUseCase"
    import { GetCartUseCaseImpl } from "../../application/usecases/GetCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeGetCartUseCase(): GetCartUseCase {
    
        return new GetCartUseCaseImpl(
    
            new MongoCartRepository()
        )
    }
============================================================
FILE: ./src/infra/factories/updateOrderStatusFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:36
============================================================

    import { UpdateOrderStatusUseCase } from "../../application/usecases/UpdateOrderStatusUseCase"
    import { UpdateOrderStatusUseCaseImpl } from "../../application/usecases/UpdateOrderStatusUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeUpdateOrderStatusUseCase(): UpdateOrderStatusUseCase {
    
        return new UpdateOrderStatusUseCaseImpl(
    
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/checkoutFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CheckoutUseCase } from "../../application/usecases/CheckoutUseCase"
    import { CheckoutUseCaseImpl } from "../../application/usecases/CheckoutUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    import { MongoProductRepository } from "../repositories/MongoProductRepository"
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    import { MongoTransactionManager } from "../transaction/MongoTransactionManager"
    import { MongoOutboxRepository } from "../repositories/MongoOutboxRepository"
    
    import { makeClearCartUseCase } from "./clearCartFactory"
    
    export function makeCheckoutUseCase(): CheckoutUseCase {
    
        const cartRepository = new MongoCartRepository()
        const productRepository = new MongoProductRepository()
        const orderRepository = new MongoOrderRepository()
        const transactionManager = new MongoTransactionManager()
        const clearCartUseCase = makeClearCartUseCase()
        const outboxRepository = new MongoOutboxRepository()
    
        return new CheckoutUseCaseImpl(
    
            cartRepository,
            productRepository,
            orderRepository,
            transactionManager,
            clearCartUseCase,
            outboxRepository
        )
    }

============================================================
FILE: ./src/infra/factories/getAllOrdersFactory.ts
LAST_MODIFIED: 2025-12-22 13:42:24
============================================================

    import { GetAllOrdersUseCase } from "../../application/usecases/GetAllOrdersUseCase"
    import { GetAllOrdersUseCaseImpl } from "../../application/usecases/GetAllOrdersUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeGetAllOrdersUseCase(): GetAllOrdersUseCase {
    
        return new GetAllOrdersUseCaseImpl(
    
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/removeItemFromCartFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { RemoveItemFromCartUseCase } from "../../application/usecases/RemoveItemFromCartUseCase"
    import { RemoveItemFromCartUseCaseImpl } from "../../application/usecases/RemoveItemFromCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeRemoveItemFromCartUseCase(): RemoveItemFromCartUseCase {
        
        const cartRepository = new MongoCartRepository()
    
        return new RemoveItemFromCartUseCaseImpl(
        
            cartRepository
        )
    }

============================================================
FILE: ./src/infra/factories/clearCartFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ClearCartUseCase } from "../../application/usecases/ClearCartUseCase"
    import { ClearCartUseCaseImpl } from "../../application/usecases/ClearCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeClearCartUseCase(): ClearCartUseCase {
    
        return new ClearCartUseCaseImpl(
    
            new MongoCartRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/addItemToCartFactory.ts
LAST_MODIFIED: 2025-12-29 17:01:39
============================================================

    import { AddItemToCartUseCaseImpl } from "../../application/usecases/AddItemToCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    import { MongoProductRepository } from "../repositories/MongoProductRepository"
    
    export function makeAddItemToCartUseCase() {
    
        return new AddItemToCartUseCaseImpl(
    
            new MongoCartRepository(),
            new MongoProductRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/listMyOrdersFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:21
============================================================

    import { ListMyOrdersUseCase } from "../../application/usecases/ListMyOrdersUseCase"
    import { ListMyOrdersUseCaseImpl } from "../../application/usecases/ListMyOrdersUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeListMyOrdersUseCase(): ListMyOrdersUseCase {
        return new ListMyOrdersUseCaseImpl(
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/outbox/MongoOutboxDispatcher.ts
LAST_MODIFIED: 2025-12-29 17:02:03
============================================================

    import { Outbox } from "../models/Outbox"
    import { OrderPlacedHandler } from "./handlers/OrderPlacedHandler"
    import { ApplicationEvent } from "../../application/events/ApplicationEvent"
    
    type EventHandler = {
        handle(event: ApplicationEvent): Promise<void>;
    };
    
    export class MongoOutboxDispatcher {
    
        private readonly handlers: Record<string, EventHandler> = {
            "order.placed": new OrderPlacedHandler(),
        }
    
        async dispatch(): Promise<void> {
    
            const events = await Outbox.find({
                processed: false,
            })
    
            for (const event of events) {
    
                const handler = this.handlers[event.name]
    
                if (!handler) {
                    // evento desconhecido ‚Üí marcar como processado
                    event.processed = true
                    event.processedAt = new Date()
                    await event.save()
                    continue
                }
    
                await handler.handle({
                    name: event.name,
                    payload: event.payload,
                    occurredAt: event.occurredAt,
                })
    
                event.processed = true
                event.processedAt = new Date()
                await event.save()
            }
        }
    }

============================================================
FILE: ./src/infra/outbox/handlers/OrderPlacedHandler.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "../../../application/events/ApplicationEvent"
    
    export class OrderPlacedHandler {
    
        async handle(event: ApplicationEvent): Promise<void> {
    
            const { orderId, userId, total } = event.payload as {
                orderId: string;
                userId: string;
                total: number;
            }
    
            // efeitos colaterais reais
            // ex:
            // await emailService.sendOrderConfirmation(...)
            // await analytics.trackOrder(...)
            // await logger.info(...)
    
            console.log(
                "[OrderPlacedHandler]",
                { orderId, userId, total }
            )
        }
    }

============================================================
FILE: ./src/infra/outbox/OutboxDispatcher.ts
LAST_MODIFIED: 2025-12-22 19:41:43
============================================================

    export interface OutboxDispatcher {
    
        dispatch(): Promise<void>;
    }

============================================================
FILE: ./src/infra/outbox/OutboxCron.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import cron from "node-cron"
    import { MongoOutboxDispatcher } from "./MongoOutboxDispatcher"
    
    const dispatcher = new MongoOutboxDispatcher()
    
    cron.schedule("*/10 * * * * *", async () => {
    
        await dispatcher.dispatch()
    })

============================================================
FILE: ./src/infra/transaction/MongoTransactionManager.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose from "mongoose"
    import { TransactionManager } from "../../application/ports/TransactionManager"
    
    export class MongoTransactionManager implements TransactionManager {
    
        async runInTransaction<T>(fn: () => Promise<T>): Promise<T> {
            const session = await mongoose.startSession()
            session.startTransaction()
    
            try {
                const result = await fn()
                await session.commitTransaction()
                return result
            } catch (error) {
                await session.abortTransaction()
                throw error
            } finally {
                await session.endSession()
            }
        }
    }

============================================================
FILE: ./src/controllers/authController.ts
LAST_MODIFIED: 2025-12-29 16:57:43
============================================================

    // FILE: ./src/controllers/authController.ts
    
    import { Request, Response } from "express"
    import bcrypt from "bcrypt"
    import jwt from "jsonwebtoken"
    import { User } from "../infra/models/User"
    
    // Importante: O '!' garante ao TypeScript que esta vari√°vel √© uma string definida,
    // j√° que carregamos o .env no server.ts.
    const JWT_SECRET = (process.env.JWT_SECRET || "supersecret") as string 
    
    // =========================================================================
    // REGISTER
    // =========================================================================
    export const registerUser = async (req: Request, res: Response) => {
    
        try {
    
            const { name, email, password } = req.body
    
            if (!name || !email || !password) {
                return res.status(400).json({ error: "Nome, email e senha s√£o obrigat√≥rios" })
            }
    
            const existingUser = await User.findOne({ email })
            if (existingUser) {
                return res.status(409).json({ error: "E-mail j√° registrado" })
            }
    
            // Hashing da senha
            const passwordHash = await bcrypt.hash(password, 10) 
    
            // Cria√ß√£o e salvamento do usu√°rio (role 'user' como padr√£o)
            const newUser = new User({
                name,
                email,
                passwordHash, 
                role: "user",
            })
            await newUser.save()
    
            // Gera√ß√£o do token
            const token = jwt.sign(
                { userId: newUser._id, role: newUser.role },
                JWT_SECRET,
                { expiresIn: "1d" },
            )
    
            // Retorna 201 Created com o token
            // O campo passwordHash √© omitido automaticamente pelo modelo (deve ser, pelo menos)
            res.status(201).json({
                token,
                user: {
                    _id: newUser._id,
                    name: newUser.name,
                    email: newUser.email,
                    role: newUser.role,
                },
            })
        }
    
        catch (error) {
    
            console.error("Erro no registro de usu√°rio:", error)
            res.status(500).json({ error: "Erro interno ao registrar usu√°rio." })
        }
    }
    
    // =========================================================================
    // LOGIN
    // =========================================================================
    export const loginUser = async (req: Request, res: Response) => {
        try {
            const { email, password } = req.body
            
            // 1. Busca o usu√°rio, OBRIGANDO a retornar o passwordHash
            // Se o campo de senha no modelo estiver com `select: false`, esta linha o recupera.
            const user = await User.findOne({ email }).select("+passwordHash")
    
            if (!user) {
                return res.status(401).json({ error: "Credenciais inv√°lidas" })
            }
    
            // 2. Compara a senha (user.passwordHash agora √© garantido)
            // Se user.passwordHash for null/undefined, bcrypt.compare lan√ßa exce√ß√£o (o que causava o 500)
            const isMatch = await bcrypt.compare(password, user.passwordHash || "") // Usamos "" como fallback seguro
    
            if (!isMatch) {
                return res.status(401).json({ error: "Credenciais inv√°lidas" })
            }
    
            // 3. Gera√ß√£o do token
            const token = jwt.sign(
                { userId: user._id, role: user.role },
                JWT_SECRET,
                { expiresIn: "1d" },
            )
    
            res.json({ token, role: user.role })
        } catch (error) {
            console.error("Erro no login (Poss√≠vel falha no bcrypt ou JWT):", error)
            res.status(500).json({ error: "Erro interno do servidor." })
        }
    }
============================================================
FILE: ./src/controllers/adminController.ts
LAST_MODIFIED: 2025-12-29 07:07:49
============================================================

    import { Request, Response } from "express"
    import { User } from "../infra/models/User"
    import { Product } from "../infra/models/Product"
    import { Order } from "../infra/models/Order"
    import { Cart } from "../infra/models/Cart"
    
    export const getStats = async (req: Request, res: Response) => {
    
        try {
    
            const { startDate, endDate } = req.query
            const start = startDate
                ? new Date(startDate as string)
                : new Date("1970-01-01")
            const end = endDate ? new Date(endDate as string) : new Date()
    
            // Filtro de data para todas as queries
            const dateFilter = { createdAt: { $gte: start, $lte: end } }
    
            // 1. Executar todas as consultas independentes em paralelo com Promise.all
            const [users, products, orders, ordersByStatus, carts, topSelling] =
    
                await Promise.all([
    
                    // Usu√°rios
                    User.find(dateFilter),
    
                    // Produtos
                    Product.find(dateFilter),
    
                    // Pedidos
                    Order.find(dateFilter),
    
                    // Pedidos por Status (Aggregation)
                    Order.aggregate([
                        { $match: dateFilter },
                        { $group: { _id: "$status", count: { $sum: 1 } } },
                    ]),
    
                    // Carrinhos
                    Cart.find(dateFilter),
    
                    // Top Selling (Aggregation)
                    Order.aggregate([
                        { $match: dateFilter },
                        { $unwind: "$items" },
                        {
                            $group: {
                                _id: "$items.productId",
                                sold: { $sum: "$items.quantity" },
                            },
                        },
                        { $sort: { sold: -1 } },
                        { $limit: 5 },
                    ]),
                ])
    
            // 2. C√°lculo e processamento dos resultados (Utilizando os dados j√° obtidos)
    
            // Processamento de Usu√°rios
            const totalUsers = users.length
            const admins = users.filter((u) => u.role === "admin").length
            const normalUsers = users.filter((u) => u.role === "user").length
    
            // Processamento de Produtos
            const totalProducts = products.length
    
            // Processamento de Pedidos
            const totalOrders = orders.length
            const revenueTotal = orders.reduce((acc, o) => acc + o.total, 0)
            const avgTicket = totalOrders > 0 ? revenueTotal / totalOrders : 0
    
            // Processamento de Carrinhos
            const avgItems =
                carts.length > 0
                    ? carts.reduce((acc, c) => acc + c.items.length, 0) /
                      carts.length
                    : 0
            const conversionRate =
                carts.length > 0 ? totalOrders / carts.length : 0
    
            // 3. Resposta Final
            res.json({
    
                period: { start, end },
                users: { total: totalUsers, admins, users: normalUsers },
                products: { total: totalProducts, topSelling },
                orders: {
                    total: totalOrders,
                    revenueTotal,
                    avgTicket,
                    byStatus: ordersByStatus,
                },
                carts: { avgItems, conversionRate },
            })
        }
    
        catch {
    
            res.status(500).json({
                error: "Erro ao gerar estat√≠sticas consolidadas",
            })
        }
    }

============================================================
FILE: ./src/controllers/orderController.ts
LAST_MODIFIED: 2025-12-29 17:05:57
============================================================

    import { Request, Response } from "express"
    import { makeCheckoutUseCase } from "../infra/factories/checkoutFactory"
    import { makeGetAllOrdersUseCase } from "../infra/factories/getAllOrdersFactory"
    import { MongoOrderRepository } from "../infra/repositories/MongoOrderRepository"
    
    const orderRepository = new MongoOrderRepository()
    
    export async function checkout(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user) return res.status(401).json({ message: "Unauthorized" })
    
            const checkoutUseCase = makeCheckoutUseCase()
            const result = await checkoutUseCase.execute({ userId: user.userId })
    
            return res.status(201).json({
                order: {
                    _id: result.orderId,
                    status: result.status,
                    total: result.total,
                },
            })
        }
    
        catch (error: any) {
    
            const code = error?.code
            const known = ["CART_EMPTY", "PRODUCT_NOT_FOUND", "INSUFFICIENT_STOCK"]
            const status = known.includes(code) ? 400 : 500
            return res.status(status).json({ error: error.message })
        }
    }
    
    // Exportando createOrder para a rota POST /
    export const createOrder = checkout
    
    export async function updateOrderStatus(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user || user.role !== "admin") return res.status(403).json({ message: "Forbidden" })
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const { status } = req.body
            const updatedOrder = await orderRepository.updateStatus(id, status)
    
            if (!updatedOrder) {
    
                return res.status(404).json({ message: "Order not found" })
            }
    
            const newOrderStatus = {
                _id: updatedOrder.id,
                status: updatedOrder.status,
                total: updatedOrder.total,
            }
    
            return res.status(200).json(newOrderStatus)
        }
    
        catch {
    
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function getMyOrders(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user) {
    
                return res.status(401).json({ message: "Unauthorized" })
            }
    
            const orders = await orderRepository.findByUserId(user.userId)
            return res.status(200).json(orders.map(o => ({ ...o, _id: o.id })))
        }
    
        catch {
    
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function getAllOrders(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user || user.role !== "admin") {
    
                return res.status(403).json({ message: "Forbidden" })
            }
    
            const useCase = makeGetAllOrdersUseCase()
            const orders = await useCase.execute({ actor: { id: user.userId, role: user.role } })
            return res.status(200).json(orders)
        }
    
        catch (error: any) {
        
            return res.status(403).json({ message: error.message })
        }
    }
============================================================
FILE: ./src/controllers/cartController.ts
LAST_MODIFIED: 2025-12-29 17:05:33
============================================================

    import { Request, Response } from "express"
    import { makeGetCartUseCase } from "../infra/factories/getCartFactory"
    import { makeAddItemToCartUseCase } from "../infra/factories/addItemToCartFactory"
    import { makeRemoveItemFromCartUseCase } from "../infra/factories/removeItemFromCartFactory"
    import { makeClearCartUseCase } from "../infra/factories/clearCartFactory"
    
    export const getCart = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) return res.status(401).json({ error: "N√£o autorizado" })
    
            const useCase = makeGetCartUseCase()
            const cart = await useCase.execute({ userId }) // objeto!
            // testes esperam items na raiz
            return res.status(200).json({ items: cart.items })
        }
    
        catch (error: any) {
    
            return res.status(500).json({ error: error.message })
        }
    }
    
    export const addItemToCart = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            const { productId, quantity } = req.body
    
            if (!userId) {
    
                return res.status(401).json({ error: "N√£o autorizado" })
            }
    
            if (!productId || !quantity) {
                return res.status(400).json({ error: "Produto e quantidade s√£o obrigat√≥rios" })
            }
    
            const useCase = makeAddItemToCartUseCase()
            await useCase.execute({ userId, productId, quantity }) // objeto!
    
            const getUseCase = makeGetCartUseCase()
            const updatedCart = await getUseCase.execute({ userId })
    
            return res.status(200).json({ cart: updatedCart })
        }
    
        catch (error: any) {
    
            const code = error?.code
            const status = code === "PRODUCT_NOT_FOUND" ? 404 : 400
            return res.status(status).json({ error: error.message })
        }
    }
    
    export const removeItemFromCart = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            const { productId } = req.body // ler do body
    
            if (!userId) {
    
                return res.status(401).json({ error: "N√£o autorizado" })
            }
    
            // checar exist√™ncia do carrinho antes
            const getUseCase = makeGetCartUseCase()
            const existing = await getUseCase.execute({ userId })
            if (!existing || existing.items.length === 0) {
                return res.status(404).json({ error: "Carrinho n√£o existe" })
            }
    
            const useCase = makeRemoveItemFromCartUseCase()
            await useCase.execute({ userId, productId })
    
            const updatedCart = await getUseCase.execute({ userId })
    
            return res.status(200).json({ cart: updatedCart })
        }
    
        catch (error: any) {
        
            return res.status(500).json({ error: error.message })
        }
    }
    
    
    export const clearCart = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "N√£o autorizado" })
            }
    
            const getUseCase = makeGetCartUseCase()
            const existing = await getUseCase.execute({ userId })
            if (!existing || existing.items.length === 0) {
    
                return res.status(404).json({ error: "Carrinho n√£o existe" })
            }
    
            const useCase = makeClearCartUseCase()
            await useCase.execute({ userId })
    
            return res.status(200).json({ message: "Carrinho limpo com sucesso", cart: { items: [] } })
        }
    
        catch (error : any) {
    
            return res.status(500).json({ error: error.message })
        }
    }

============================================================
FILE: ./src/controllers/addressController.ts
LAST_MODIFIED: 2025-12-29 16:57:17
============================================================

    import { Request, Response } from "express"
    import { Address } from "../infra/models/Address"
    import mongoose from "mongoose"
    
    // Fun√ß√£o auxiliar para garantir que apenas um endere√ßo seja o padr√£o
    const ensureOnlyOneDefault = async (userId: mongoose.Types.ObjectId, currentAddressId?: mongoose.Types.ObjectId) => {
    
        // Define todos os outros endere√ßos (exceto o atual, se fornecido) como n√£o-padr√£o
        const filter: any = { userId }
        if (currentAddressId) {
    
            filter._id = { $ne: currentAddressId }
        }
    
        await Address.updateMany(filter, { isDefault: false })
    }
    
    // =========================================================================
    // POST /api/addresses - Criar novo endere√ßo
    // =========================================================================
    export const createAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const { street, city, state, zipCode, country, isDefault } = req.body
    
            if (!street || !city || !state || !zipCode) {
    
                return res.status(400).json({ error: "Campos obrigat√≥rios ausentes." })
            }
    
            const addressData = {
                userId,
                street,
                city,
                state,
                zipCode,
                country,
                isDefault: isDefault === true,
            }
    
            if (addressData.isDefault) {
    
                await ensureOnlyOneDefault(new mongoose.Types.ObjectId(userId))
            }
    
            const newAddress = new Address(addressData)
            await newAddress.save()
            
            res.status(201).json({ message: "Endere√ßo criado com sucesso", address: newAddress })
        }
    
        catch (error) {
    
            console.error("Erro ao criar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao criar endere√ßo." })
        }
    }
    
    // =========================================================================
    // GET /api/addresses - Listar todos os endere√ßos do usu√°rio
    // =========================================================================
    export const getAddresses = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const addresses = await Address.find({ userId }).sort({ isDefault: -1, createdAt: 1 })
            
            res.json(addresses)
        }
    
        catch (error) {
    
            console.error("Erro ao buscar endere√ßos:", error)
            res.status(500).json({ error: "Erro interno ao buscar endere√ßos." })
        }
    }
    
    // =========================================================================
    // PUT /api/addresses/:id - Atualizar endere√ßo
    // =========================================================================
    export const updateAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
    
            const { id } = req.params
            const updateData = req.body
            
            // Garante que o usu√°rio s√≥ pode atualizar seus pr√≥prios endere√ßos
            const objectId = new mongoose.Types.ObjectId(id)
            const objectUserId = new mongoose.Types.ObjectId(userId)
    
            const address = await Address.findOne({ _id: objectId, userId: objectUserId })
            if (!address) {
    
                return res.status(404).json({ error: "Endere√ßo n√£o encontrado ou n√£o pertence ao usu√°rio." })
            }
    
            if (updateData.isDefault === true) {
    
                await ensureOnlyOneDefault(new mongoose.Types.ObjectId(userId), new mongoose.Types.ObjectId(id))
            }
    
            const updatedAddress = await Address.findByIdAndUpdate(id, updateData, { new: true })
            
            res.json({ message: "Endere√ßo atualizado com sucesso", address: updatedAddress })
        }
    
        catch (error) {
    
            console.error("Erro ao atualizar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao atualizar endere√ßo." })
        }
    }
    
    // =========================================================================
    // DELETE /api/addresses/:id - Deletar endere√ßo
    // =========================================================================
    export const deleteAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const { id } = req.params
    
            const objectId = new mongoose.Types.ObjectId(id)
            const objectUserId = new mongoose.Types.ObjectId(userId)
            
            // Garante que o usu√°rio s√≥ pode deletar seus pr√≥prios endere√ßos
            const deletedAddress = await Address.findOneAndDelete({ _id: objectId, userId: objectUserId })
            
            if (!deletedAddress) {
    
                return res.status(404).json({ error: "Endere√ßo n√£o encontrado ou n√£o pertence ao usu√°rio." })
            }
            
            res.json({ message: "Endere√ßo removido com sucesso" })
        }
    
        catch (error) {
    
            console.error("Erro ao deletar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao deletar endere√ßo." })
        }
    }
============================================================
FILE: ./src/controllers/userController.ts
LAST_MODIFIED: 2025-12-29 16:56:49
============================================================

    import { Request, Response } from "express"
    import { User } from "../infra/models/User"
    
    export const getAllUsers = async (req: Request, res: Response) => {
    
        try {
    
            const users = await User.find().select("-passwordHash")
            res.json(users)
    
        }
    
        catch {
    
            res.status(500).json({ error: "Erro ao listar usu√°rios" })
        }
    }
    
    export const getUserById = async (req: Request, res: Response) => {
    
        try {
    
            const user = await User.findById(req.params.id).select("-passwordHash")
            if (!user) {
    
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
            }
    
            res.json(user)
        }
    
        catch {
        
            res.status(500).json({ error: "Erro ao buscar usu√°rio" })
        }
    }
    
    export const updateUser = async (req: Request, res: Response) => {
    
        try {
    
            const updatedUser = await User.findByIdAndUpdate(
                req.params.id,
                req.body,
                { new: true },
            ).select("-passwordHash")
            if (!updatedUser) {
    
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
            }
    
            res.json({
                message: "Usu√°rio atualizado com sucesso!",
                user: updatedUser,
            })
        }
    
        catch {
    
            res.status(500).json({ error: "Erro ao atualizar usu√°rio" })
        }
    }
    
    export const deleteUser = async (req: Request, res: Response) => {
    
        try {
    
            const deletedUser = await User.findByIdAndDelete(req.params.id)
            if (!deletedUser) {
    
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
            }
    
            res.json({ message: "Usu√°rio removido com sucesso!" })
        }
    
        catch {
    
            res.status(500).json({ error: "Erro ao remover usu√°rio" })
        }
    }

============================================================
FILE: ./src/controllers/productController.ts
LAST_MODIFIED: 2025-12-29 16:55:27
============================================================

    import { Request, Response } from "express"
    import { MongoProductRepository } from "../infra/repositories/MongoProductRepository"
    
    const productRepository = new MongoProductRepository()
    
    // GET /api/products ‚Äî rota p√∫blica
    export async function getAllProducts(req: Request, res: Response) {
    
        try {
    
            const products = await productRepository.findAll()
            return res.status(200).json(products)   // üîπ j√° vem com _id
        }
    
        catch (error) {
        
            console.error("GET PRODUCTS ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function createProduct(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user) {
    
                return res.status(401).json({ message: "Unauthorized" })
            }
            if (user.role !== "admin") {
    
                return res.status(403).json({ message: "Forbidden" })
            }
    
            const { name, price, stock, description } = req.body
            if (!name || price === undefined) {
    
                return res.status(400).json({ error: "Campos obrigat√≥rios: name e price" })
            }
    
            const created = await productRepository.create({
                name,
                price,
                stock: stock ?? 0,
                description: description ?? "",
            })
    
            // üîπ garantir que _id esteja presente no objeto retornado
            return res.status(201).json({
                product: {
                    _id: created._id,
                    name: created.name,
                    price: created.price,
                    stock: created.stock,
                    description: created.description,
                }
            })
        }
    
        catch (error) {
        
            console.error("CREATE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function updateProduct(req: Request, res: Response) {
    
        try {
    
            const user = req.user
    
            if (!user) {
    
                return res.status(401).json({ message: "Unauthorized" })
            }
    
            if (user.role !== "admin") {
    
                return res.status(403).json({ message: "Forbidden" })
            }
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const { name, price, stock, description } = req.body
    
            const updated = await productRepository.update(id, {
                name,
                price,
                stock,
                description,
            })
    
            if (!updated) return res.status(404).json({ message: "Produto n√£o encontrado" })
    
            // üîπ garantir que _id esteja presente
            return res.status(200).json({
                product: {
                    _id: updated._id,
                    name: updated.name,
                    price: updated.price,
                    stock: updated.stock,
                    description: updated.description,
                }
            })
        }
    
        catch (error) {
    
            console.error("UPDATE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    // DELETE /api/products/:id ‚Äî apenas admin
    export async function deleteProduct(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user) {
    
                return res.status(401).json({ message: "Unauthorized" })
            }
            if (user.role !== "admin") {
    
                return res.status(403).json({ message: "Forbidden" })
            }
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const deleted = await productRepository.delete(id)
    
            if (!deleted) return res.status(404).json({ message: "Produto n√£o encontrado" })
    
            // üîπ manter consist√™ncia: resposta dentro de product
            return res.status(200).json({ product: { deleted: true, _id: id } })
        }
    
        catch (error) {
    
            console.error("DELETE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    

============================================================
FILE: ./src/utils/logger.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/utils/logger.ts
    
    /**
     * N√≠veis de severidade de log.
     */
    type LogLevel = "INFO" | "WARN" | "ERROR" | "DEBUG";
    
    /**
     * Fun√ß√£o de log simples e formatada.
     * Ideal para logs no servidor, adicionando timestamps e n√≠veis.
     * * @param level O n√≠vel de severidade da mensagem.
     * @param message A mensagem principal a ser logada.
     * @param details (Opcional) Detalhes adicionais, como um objeto de erro.
     */
    export const log = (
        level: LogLevel,
        message: string,
        details?: any
    ) => {
        // 1. Defini√ß√£o do carimbo de data/hora (Timestamp)
        const timestamp = new Date().toISOString()
    
        // 2. Formata√ß√£o da mensagem principal
        const logMessage = `[${timestamp}] [${level}] - ${message}`
    
        // 3. Escolha do console method baseado no n√≠vel
        const consoleMethod = 
            level === "ERROR" ? console.error :
                level === "WARN" ? console.warn :
                    console.log // INFO ou DEBUG
    
        // 4. Exibir o log
        if (details) {
            // Se houver detalhes, loga a mensagem e os detalhes no console
            consoleMethod(logMessage, details)
        } else {
            // Se n√£o houver detalhes, loga apenas a mensagem
            consoleMethod(logMessage)
        }
    
        // Nota: Em um ambiente real, voc√™ faria aqui:
        // - Envio para um servi√ßo de monitoramento (e.g., Sentry, DataDog).
        // - Escrita em um arquivo de log (File System).
    }
    
    // Exemplo de uso
    // log('INFO', 'Servidor inicializado com sucesso.');
    // log('ERROR', 'Falha ao conectar ao DB', new Error('Connection refused'));
============================================================
FILE: ./src/server.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose from "mongoose"
    import { config } from "dotenv"
    import app from "./app"
    
    config()
    
    const PORT = process.env.PORT || 4000
    
    mongoose
        .connect(process.env.MONGO_URI as string)
        .then(() => {
            console.log("Conectado ao MongoDB Atlas")
            app.listen(PORT, () => {
                console.log(`Servidor rodando na porta ${PORT}`)
            })
        })
        .catch((err) => {
            console.error("Erro ao conectar ao MongoDB:", err)
        })

============================================================
FILE: ./src/domain/types/ProductSnapshot.ts
LAST_MODIFIED: 2025-12-19 15:56:09
============================================================

    export type ProductSnapshot = {
        id: string;
        price: number;
        stock: number;
    };

============================================================
FILE: ./src/domain/types/OrderItem.ts
LAST_MODIFIED: 2025-12-19 16:22:37
============================================================

    export type OrderItem = {
        productId: string;
        quantity: number;
    };

============================================================
FILE: ./src/domain/errors/InvalidStatusTransactionError.ts
LAST_MODIFIED: 2025-12-29 15:52:22
============================================================

    import { DomainError } from "./DomainError"
    
    export class InvalidStatusTransactionError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/OrderCannotBeCancelledError.ts
LAST_MODIFIED: 2025-12-29 15:49:54
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderCannotBeCancelledError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/OrderWithoutItemsError.ts
LAST_MODIFIED: 2025-12-29 15:51:00
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderWithoutItemsError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/DomainError.ts
LAST_MODIFIED: 2025-12-29 15:43:33
============================================================

    export abstract class DomainError extends Error {
    
        public readonly code: string
    
        constructor(code: string, message: string) {
    
            super(message)
            this.code = code
            this.name = this.constructor.name
        }
    }

============================================================
FILE: ./src/domain/errors/OrderNotFoundError.ts
LAST_MODIFIED: 2025-12-29 15:50:27
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderNotFoundError extends DomainError {
    
        constructor(code: string, message: string = "Order not found") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/CheckoutErrors.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { DomainError } from "./DomainError"
    
    export class CartEmptyError extends DomainError {
        constructor() {
            super("CART_EMPTY", "Carrinho vazio")
            this.name = "CartEmptyError"
        }
    }
    
    export class ProductNotFoundError extends DomainError {
        constructor(productId?: string) {
            super(
                "PRODUCT_NOT_FOUND",
                productId ? `Produto ${productId} n√£o encontrado` : "Produto n√£o encontrado"
            )
            this.name = "ProductNotFoundError"
        }
    }
    
    export class InsufficientStockError extends DomainError {
        constructor(productId: string, available: number, requested: number) {
            super(
                "INSUFFICIENT_STOCK",
                `Estoque insuficiente para o produto ${productId}. Dispon√≠vel: ${available}, solicitado: ${requested}`
            )
            this.name = "InsufficientStockError"
        }
    }

============================================================
FILE: ./src/domain/errors/AccessDeniedError.ts
LAST_MODIFIED: 2025-12-29 15:48:27
============================================================

    import { DomainError } from "./DomainError"
    
    export class AccessDeniedError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/CartNotFoundError.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    export class CartNotFoundError extends Error {
    
        public readonly userId: string
    
        constructor(userId: string) {
            super(`Cart not found for user ${userId}`)
            this.name = "CartNotFoundError"
            this.userId = userId
        }
    }
    

============================================================
FILE: ./src/domain/errors/InvalidErrorTotalError.ts
LAST_MODIFIED: 2025-12-29 15:48:58
============================================================

    import { DomainError } from "./DomainError"
    
    export class InvalidErrorTotalError extends DomainError {
    
        constructor(code: string, message:string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/ProductNotFoundError.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    export class ProductNotFoundError extends Error {
        public readonly productId: string
        public readonly code = "PRODUCT_NOT_FOUND"
    
        constructor(productId: string) {
            super(`Produto ${productId} n√£o encontrado`)
            this.name = "ProductNotFoundError"
            this.productId = productId
        }
    }

============================================================
FILE: ./src/domain/errors/OnlyAdminCanChangeOrderStatusError.ts
LAST_MODIFIED: 2025-12-29 15:55:38
============================================================

    import { DomainError } from "./DomainError"
    
    export class OnlyAdminCanChangeOrderStatusError extends DomainError {
    
        constructor(code: string, message:string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/events/DomainEventHandler.ts
LAST_MODIFIED: 2025-12-17 19:30:10
============================================================

    export interface DomainEventHandler<T> {
        handle(event: T): Promise<void> | void;
    }

============================================================
FILE: ./src/domain/events/EventBus.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "./DomainEventHandler"
    
    type EventClass<T> = new (...args: any[]) => T;
    
    export class EventBus {
    
        private handlers = new Map<string, DomainEventHandler<any>[]>()
    
        subscribe<T extends object>(
            event: EventClass<T>,
            handler: DomainEventHandler<T>
        ) {
    
            const eventName = event.name
    
            const existing = this.handlers.get(eventName) ?? []
            existing.push(handler)
    
            this.handlers.set(eventName, existing)
        }
    
        async publish<T extends object>(event: T) {
    
            const eventName = event.constructor.name
            const handlers = this.handlers.get(eventName) ?? []
    
            for (const handler of handlers) {
                await handler.handle(event)
            }
        }
    }

============================================================
FILE: ./src/domain/events/OrderCreatedEvent.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    export class OrderCreatedEvent {
    
        readonly occurredAt: Date
    
        constructor(
            public readonly orderId: string,
            public readonly userId: string,
            public readonly total: number
        ) {
    
            this.occurredAt = new Date()
        }
    }

============================================================
FILE: ./src/domain/services/OrderStatusDomainService.ts
LAST_MODIFIED: 2025-12-29 17:22:02
============================================================

    import { InvalidStatusTransactionError } from "../errors/InvalidStatusTransactionError"
    import { OnlyAdminCanChangeOrderStatusError } from "../errors/OnlyAdminCanChangeOrderStatusError"
    
    const allowedTransitions: Record<string, string[]> = {
        pending: ["paid"],
        paid: ["shipped"],
        shipped: ["delivered"],
    }
    
    export class OrderStatusDomainService {
    
        validateTransition( currentStatus: string, newStatus: string ) {
            const allowed = allowedTransitions[currentStatus] || []
    
            if (!allowed.includes(newStatus)) {
                throw new InvalidStatusTransactionError(
                    "INVALID_STATUS_TRANSACTION", `Invalid status transition from ${currentStatus} to ${newStatus}`
                )
            }
        }
    
        validatePermission( actorRole: "admin" | "user" ) {
    
            if (actorRole !== "admin") {
    
                throw new OnlyAdminCanChangeOrderStatusError("ONLY_ADMIN_CAN_CHANGE_ORDER_STATUS", "Only admin can change order status")
            }
        }
    }

============================================================
FILE: ./src/domain/services/OrderValidationService.ts
LAST_MODIFIED: 2025-12-29 17:07:28
============================================================

    import { OrderItem } from "../types/OrderItem"
    import { ProductSnapshot } from "../types/ProductSnapshot"
    import { ProductNotFoundError, InsufficientStockError } from "../errors/CheckoutErrors"
    
    export class OrderValidationService {
    
        validateAndCalculateTotal(items: OrderItem[], products: ProductSnapshot[]): number {
    
            const productMap: Record<string, ProductSnapshot> = {}
            for (const product of products) {
                productMap[product.id] = product
            }
    
            let total = 0
    
            for (const item of items) {
                const product = productMap[item.productId]
    
                if (!product) {
                    throw new ProductNotFoundError(item.productId)
                }
    
                if (product.stock < item.quantity) {
                    throw new InsufficientStockError(item.productId, product.stock, item.quantity)
                }
    
                total += product.price * item.quantity
            }
    
            return total
        }
    }

============================================================
FILE: ./src/domain/entities/Order.ts
LAST_MODIFIED: 2025-12-29 15:41:49
============================================================

    import { OrderWithoutItemsError } from "../errors/OrderWithoutItemsError"
    import { InvalidErrorTotalError } from "../errors/InvalidErrorTotalError"
    import { InvalidStatusTransactionError } from "../errors/InvalidStatusTransactionError"
    import { OrderCannotBeCancelledError } from "../errors/OrderCannotBeCancelledError"
    
    export type OrderStatus =
      | "pending"
      | "paid"
      | "shipped"
      | "completed"
      | "cancelled";
    
    export interface OrderItem {
        productId: string;
        quantity: number;
    }
    
    export class Order {
    
        private _status: OrderStatus
    
        private readonly _items: OrderItem[]
    
        private readonly _total: number
    
        constructor(
    
            status: OrderStatus,
            items: OrderItem[],
            total: number
        ) {
    
            if (items.length === 0) {
    
                throw new OrderWithoutItemsError("ORDER_WITHOUT_ITEMS")
            }
    
            if (total <= 0) {
    
                throw new InvalidErrorTotalError("INVALID_ORDER_TOTAL")
            }
    
            this._status = status
            this._items = items
            this._total = total
        }
    
        // =====================
        // Getters
        // =====================
    
        get status() {
    
            return this._status
        }
    
        get total() {
    
            return this._total
        }
    
        get items() {
    
            return [...this._items]
        }
    
        // =====================
        // Comportamentos
        // =====================
    
        markAsPaid() {
    
            if (this._status !== "pending") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot pay order in status ${this._status}`
                )
            }
    
            this._status = "paid"
        }
    
        ship() {
    
            if (this._status !== "paid") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot ship order in status ${this._status}`
                )
            }
    
            this._status = "shipped"
        }
    
        complete() {
    
            if (this._status !== "shipped") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot complete order in status ${this._status}`
                )
            }
    
            this._status = "completed"
        }
    
    
        cancel() {
    
            if (this._status === "shipped") {
    
                throw new OrderCannotBeCancelledError(
    
                    "ORDER_CANNOT_BE_CANCELLED",
                    "Order already shipped"
                )
            }
    
            this._status = "cancelled"
        }
    }

============================================================
FILE: ./src/app.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import express from "express"
    import cors from "cors"
    import authRoutes from "./routes/authRoutes"
    import cartRoutes from "./routes/cartRoutes"
    import productRoutes from "./routes/productRoutes"
    import adminRoutes from "./routes/adminRoutes"
    import userRoutes from "./routes/userRoutes"
    import orderRoutes from "./routes/orderRoutes"
    import addressRoutes from "./routes/addressRoutes"
    
    const app = express()
     
    // Middlewares
    app.use(cors())
    app.use(express.json())
    
    app.use("/api/admin", adminRoutes)
    app.use("/api/auth", authRoutes)
    app.use("/api/users", userRoutes)
    app.use("/api/cart", cartRoutes)
    app.use("/api/products", productRoutes)
    app.use("/api/orders", orderRoutes)
    app.use("/api/addresses", addressRoutes)
    
    export default app

============================================================
FILE: ./src/@types/express/index.d.ts
LAST_MODIFIED: 2025-12-28 17:22:13
============================================================

    import "express"
    
    declare module "express-serve-static-core" {
    
        interface Request {
    
            user?: {
                userId: string;
                role: "user" | "admin";
            };
        }
    }
    

============================================================
FILE: ./src/application/handlers/UpdateSalesMetricsHandler.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "../../domain/events/DomainEventHandler"
    import { OrderCreatedEvent } from "../../domain/events/OrderCreatedEvent"
    
    export class UpdateSalesMetricsHandler
    implements DomainEventHandler<OrderCreatedEvent> {
    
        async handle(event: OrderCreatedEvent) {
            console.log(
                `[METRICS] Nova venda registrada: R$ ${event.total}`
            )
        }
    }

============================================================
FILE: ./src/application/handlers/SendOrderEmailHandler.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "../../domain/events/DomainEventHandler"
    import { OrderCreatedEvent } from "../../domain/events/OrderCreatedEvent"
    
    export class SendOrderEmailHandler
    implements DomainEventHandler<OrderCreatedEvent> {
    
        async handle(event: OrderCreatedEvent) {
            console.log(
                `[EMAIL] Pedido ${event.orderId} criado para usu√°rio ${event.userId}`
            )
        }
    }

============================================================
FILE: ./src/application/usecases/ListMyOrdersUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 12:36:00
============================================================

    import {
        ListMyOrdersUseCase,
        ListMyOrdersInput,
        OrderSummary
    } from "./ListMyOrdersUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    
    export class ListMyOrdersUseCaseImpl
    implements ListMyOrdersUseCase {
    
        constructor(
            private readonly orderRepository: OrderRepository
        ) {}                                    
    
        async execute(
            { userId }: ListMyOrdersInput
        ): Promise<OrderSummary[]> {
    
            return this.orderRepository.findByUserId(userId)
        }
    }

============================================================
FILE: ./src/application/usecases/GetAllOrdersUseCase.ts
LAST_MODIFIED: 2025-12-29 13:58:09
============================================================

    export type OrderSummary = {
    
        id: string;
        userId: string;
        status: string;
        total: number;
        createdAt: Date;
    };
    
    export type GetAllOrdersInput = {
    
        actor: {
            id: string;
            role: "admin" | "user";
        };
    };
    
    export interface GetAllOrdersUseCase {
    
        execute(input: GetAllOrdersInput): Promise<OrderSummary[]>;
    }

============================================================
FILE: ./src/application/usecases/RemoveItemFromCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 06:57:59
============================================================

    import {
        RemoveItemFromCartUseCase,
        RemoveItemFromCartInput,
    } from "./RemoveItemFromCartUseCase"
    
    import { CartRepository } from "../ports/CartRepository"
    import { CartNotFoundError } from "../../domain/errors/CartNotFoundError"
    
    export class RemoveItemFromCartUseCaseImpl
    implements RemoveItemFromCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute( { userId, productId }: RemoveItemFromCartInput ): Promise<void> {
    
            const cart = await this.cartRepository.findByUserId(userId)
            if (!cart) {
                throw new CartNotFoundError(`Cart for user ${userId} not found`)
            }
            await this.cartRepository.removeItem(userId, productId)
        }
    }

============================================================
FILE: ./src/application/usecases/ClearCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ClearCartUseCase, ClearCartInput } from "./ClearCartUseCase"
    import { CartRepository } from "../ports/CartRepository"
    
    export class ClearCartUseCaseImpl implements ClearCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute({ userId }: ClearCartInput): Promise<void> {
    
            const cart = await this.cartRepository.findByUserId(userId)
    
            // comportamento idempotente:
            // se o carrinho n√£o existe, n√£o √© erro
            if (!cart) {
                return
            }
    
            await this.cartRepository.clear(userId)
        }
    }

============================================================
FILE: ./src/application/usecases/RemoveItemFromCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:31:15
============================================================

    export type RemoveItemFromCartInput = {
        userId: string;
        productId: string;
    };
    
    export interface RemoveItemFromCartUseCase {
        execute(input: RemoveItemFromCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/UpdateOrderStatusUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 17:21:51
============================================================

    import {
        UpdateOrderStatusUseCase,
        UpdateOrderStatusInput,
        UpdateOrderStatusOutput
    } from "./UpdateOrderStatusUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    import { OrderStatusDomainService } from "../../domain/services/OrderStatusDomainService"
    import { OrderNotFoundError } from "../../domain/errors/OrderNotFoundError"
    
    export class UpdateOrderStatusUseCaseImpl
    implements UpdateOrderStatusUseCase {
    
        private readonly statusService = new OrderStatusDomainService()
    
        constructor(
            private readonly orderRepository: OrderRepository
        ) {}
    
        async execute(
            input: UpdateOrderStatusInput
        ): Promise<UpdateOrderStatusOutput> {
    
            const order = await this.orderRepository.findById(input.orderId)
    
            if (!order) {
                throw new OrderNotFoundError("Order not found")
            }
    
            this.statusService.validatePermission(
                input.actor.role
            )
    
            this.statusService.validateTransition(
                order.status,
                input.newStatus
            )
    
            await this.orderRepository.updateStatus(
                order.id,
                input.newStatus
            )
    
            return {
                orderId: order.id,
                previousStatus: order.status,
                currentStatus: input.newStatus
            }
        }
    }

============================================================
FILE: ./src/application/usecases/UpdateOrderStatusUseCase.ts
LAST_MODIFIED: 2025-12-19 14:19:39
============================================================

    export type UpdateOrderStatusInput = {
        orderId: string;
        newStatus: string;
        actor: {
            id: string;
            role: "admin" | "user";
        };
    };
    
    export type UpdateOrderStatusOutput = {
        orderId: string;
        previousStatus: string;
        currentStatus: string;
    };
    
    export interface UpdateOrderStatusUseCase {
        execute(input: UpdateOrderStatusInput): Promise<UpdateOrderStatusOutput>;
    }

============================================================
FILE: ./src/application/usecases/ListMyOrdersUseCase.ts
LAST_MODIFIED: 2025-12-29 12:44:04
============================================================

    export type ListMyOrdersInput = {
        userId: string;
    };
    
    export type OrderSummary = {
        id: string;
        status: string;
        total: number;
        createdAt?: Date;
    };
    
    export interface ListMyOrdersUseCase {
        execute(input: ListMyOrdersInput): Promise<OrderSummary[]>;
    }

============================================================
FILE: ./src/application/usecases/CheckoutUseCase.ts
LAST_MODIFIED: 2025-12-29 12:44:24
============================================================

    export type CheckoutInput = {
    
        userId: string;
    };
    
    export type CheckoutOutput = {
    
        orderId: string;
        status: string;
        total: number;
    };
    
    export interface CheckoutUseCase {
    
        execute(input: CheckoutInput): Promise<CheckoutOutput>;
    }

============================================================
FILE: ./src/application/usecases/GetCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-22 12:37:19
============================================================

    import { GetCartUseCase, GetCartInput, CartOutput } from "./GetCartUseCase"
    import { CartRepository } from "../ports/CartRepository"
    
    export class GetCartUseCaseImpl
    implements GetCartUseCase {
    
        constructor(
    
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute({ userId }: GetCartInput): Promise<CartOutput> {
    
            const cart = await this.cartRepository.findByUserId(userId)
    
            return {
    
                items: cart?.items ?? []
            }
        }
    }

============================================================
FILE: ./src/application/usecases/ClearCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:27:22
============================================================

    export type ClearCartInput = {
        userId: string;
    };
    
    export interface ClearCartUseCase {
        execute(input: ClearCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/GetAllOrdersUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 15:47:45
============================================================

    import {
        GetAllOrdersUseCase,
        GetAllOrdersInput,
        OrderSummary
    } from "./GetAllOrdersUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    import { AccessDeniedError } from "../../domain/errors/AccessDeniedError"
    
    export class GetAllOrdersUseCaseImpl
    implements GetAllOrdersUseCase {
    
        constructor(
    
            private readonly orderRepository: OrderRepository
        ) {}
    
        async execute(
            { actor }: GetAllOrdersInput
        ): Promise<OrderSummary[]> {
    
            if (actor.role !== "admin") {
                throw new AccessDeniedError("ACCESS_DENIED", "Access denied")
            }
    
            return this.orderRepository.findAll()
        }
    }

============================================================
FILE: ./src/application/usecases/AddItemToCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import {
        AddItemToCartUseCase,
        AddItemToCartInput,
    } from "./AddItemToCartUseCase"
    
    import { CartRepository } from "../ports/CartRepository"
    import { ProductRepository } from "../ports/ProductRepository"
    
    import { ProductNotFoundError } from "../../domain/errors/ProductNotFoundError"
    import { InsufficientStockError } from "../../domain/errors/CheckoutErrors"
    
    export class AddItemToCartUseCaseImpl implements AddItemToCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository,
            private readonly productRepository: ProductRepository
        ) {}
    
        async execute({
            userId,
            productId,
            quantity,
        }: AddItemToCartInput): Promise<void> {
    
            // 1. Verificar se o produto existe
            const product = await this.productRepository.findById(productId)
    
            if (!product) {
                throw new ProductNotFoundError(productId)
            }
    
            // 2. Verificar estoque
            if (product.stock < quantity) {
                throw new InsufficientStockError(
                    productId,
                    product.stock,
                    quantity
                )
            }
    
            // 3. Delegar a persist√™ncia ao reposit√≥rio
            await this.cartRepository.addItem(
                userId,
                productId,
                quantity
            )
        }
    }

============================================================
FILE: ./src/application/usecases/GetCartUseCase.ts
LAST_MODIFIED: 2025-12-22 12:34:15
============================================================

    export type GetCartInput = {
    
        userId: string;
    };
    
    export type CartItemOutput = {
    
        productId: string;
        quantity: number;
    };
    
    export type CartOutput = {
    
        items: CartItemOutput[];
    };
    
    export interface GetCartUseCase {
    
        execute(input: GetCartInput): Promise<CartOutput>;
    }

============================================================
FILE: ./src/application/usecases/AddItemToCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:20:25
============================================================

    export type AddItemToCartInput = {
        userId: string;
        productId: string;
        quantity: number;
    };
    
    export interface AddItemToCartUseCase {
        execute(input: AddItemToCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/CheckoutUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CheckoutUseCase } from "./CheckoutUseCase"
    import { CartRepository } from "../ports/CartRepository"
    import { ProductRepository } from "../ports/ProductRepository"
    import { OrderRepository } from "../ports/OrderRepository"
    import { TransactionManager } from "../ports/TransactionManager"
    import { ClearCartUseCase } from "./ClearCartUseCase"
    import { OutboxRepository } from "../ports/OutboxRepository"
    import { CartEmptyError } from "../../domain/errors/CheckoutErrors"
    import { OrderValidationService } from "../../domain/services/OrderValidationService"
    
    export class CheckoutUseCaseImpl implements CheckoutUseCase {
        constructor(
        private readonly cartRepository: CartRepository,
        private readonly productRepository: ProductRepository,
        private readonly orderRepository: OrderRepository,
        private readonly transactionManager: TransactionManager,
        private readonly clearCartUseCase: ClearCartUseCase,
        private readonly outboxRepository: OutboxRepository   // ‚úÖ novo par√¢metro
        ) {}
    
        async execute(input: { userId: string }): Promise<{ orderId: string; status: string; total: number }> {
            return this.transactionManager.runInTransaction(async () => {
                const cart = await this.cartRepository.findByUserId(input.userId)
                if (!cart || cart.items.length === 0) {
                    throw new CartEmptyError()
                }
    
                const products = await this.productRepository.findByIds(cart.items.map(i => i.productId))
                const total = new OrderValidationService().validateAndCalculateTotal(cart.items, products)
    
                for (const item of cart.items) {
                    await this.productRepository.decrementStock(item.productId, item.quantity)
                }
    
                const order = await this.orderRepository.create({
                    userId: input.userId,
                    items: cart.items,
                    total,
                    status: "pending",
                })
    
                await this.clearCartUseCase.execute({ userId: input.userId })
    
                // üî• Persistir evento no Outbox
                await this.outboxRepository.save({
                    name: "order.placed",
                    payload: {
                        orderId: order.id,
                        userId: input.userId,
                        total,
                    },
                    occurredAt: new Date(),
                })
    
                return { orderId: order.id, status: "pending", total }
            })
        }
    }

============================================================
FILE: ./src/application/events/ApplicationEvent.ts
LAST_MODIFIED: 2025-12-22 17:55:29
============================================================

    export interface ApplicationEvent {
    
        readonly name: string;
        readonly occurredAt: Date;
        readonly payload: unknown;
    }

============================================================
FILE: ./src/application/events/OrderPlacedEvent.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "./ApplicationEvent"
    
    export class OrderPlacedEvent implements ApplicationEvent {
    
        readonly name = "order.placed"
        readonly occurredAt = new Date()
    
        constructor(
    
            public readonly payload: {
    
                orderId: string;
                userId: string;
                total: number;
            }
        ) {}
    }

============================================================
FILE: ./src/application/ports/OutboxRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "../events/ApplicationEvent"
    
    export interface OutboxRepository {
    
        save(event: ApplicationEvent): Promise<void>;
    }

============================================================
FILE: ./src/application/ports/TransactionManager.ts
LAST_MODIFIED: 2025-12-19 15:31:58
============================================================

    export interface TransactionManager {
        runInTransaction<T>(fn: () => Promise<T>): Promise<T>;
    }

============================================================
FILE: ./src/application/ports/CartRepository.ts
LAST_MODIFIED: 2025-12-27 12:11:57
============================================================

    export interface CartRepository {
    
      findByUserId(
        userId: string
      ): Promise<{
        userId: string;
        items: { productId: string; quantity: number }[];
      } | null>;
    
      addItem(
        userId: string,
        productId: string,
        quantity: number
      ): Promise<void>;
    
      removeItem(
        userId: string,
        productId: string
      ): Promise<void>;
    
      clear(
        userId: string
      ): Promise<void>;
    }

============================================================
FILE: ./src/application/ports/OrderRepository.ts
LAST_MODIFIED: 2025-12-29 14:58:25
============================================================

    export interface OrderRepository {
    
        findById(id: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        } | null>;
    
        findByUserId(userId: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        }[]>;
    
        findAll(): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
            createdAt: Date;
        }[]>;
    
        create(data: {
            userId: string;
            items: any[];
            total: number;
            status: string;
        }): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        }>;
    
        updateStatus(id: string, status: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        } | null>;
    
        create(order: any): Promise<any>; // Adiciona esta linha
    }

============================================================
FILE: ./src/application/ports/ProductRepository.ts
LAST_MODIFIED: 2025-12-22 13:57:09
============================================================

    export type ProductData = {
    
        id: string;
        price: number;
        stock: number;
    };
    
    export interface ProductRepository {
    
        findById(id: string): Promise<{
    
            id: string;
            stock: number;
        } | null>;
    
        findByIds(ids: string[]): Promise<ProductData[]>;
        decrementStock(productId: string, quantity: number): Promise<void>;
    }
    
    

============================================================
FILE: ./src/middlewares/adminAuth.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/middlewares/adminAuth.ts
    
    import { Request, Response, NextFunction } from "express"
    
    export const adminAuth = (req: Request, res: Response, next: NextFunction)=> {
        // 1. Verifica se o usu√°rio foi autenticado
        if (!req.user || !req.user.role) {
            return res.status(401).json({ error: "Acesso negado. Token inv√°lido ou ausente." })
        }
        
        // 2. Verifica se o papel (role) √© 'admin'
        if (req.user.role !== "admin") {
            return res.status(403).json({ error: "Acesso negado. Requer permiss√£o de Administrador." })
        }
    
        next()
    }
============================================================
FILE: ./src/middlewares/authMiddleware.ts
LAST_MODIFIED: 2025-12-29 16:39:50
============================================================

    import jwt from "jsonwebtoken"
    import { Request, Response, NextFunction } from "express"
    
    type AuthTokenPayload = {
        userId: string
        role: "user" | "admin"
    }
    
    function isAuthTokenPayload(payload: any): payload is AuthTokenPayload {
        return (
            payload &&
            typeof payload === "object" &&
            typeof payload.userId === "string" &&
            (payload.role === "user" || payload.role === "admin")
        )
    }
    
    export const authenticate = (
        req: Request,
        res: Response,
        next: NextFunction
    ) => {
        const authHeader = req.headers.authorization
        if (!authHeader) {
            return res.status(401).json({ error: "Token n√£o fornecido" })
        }
    
        const parts = authHeader.split(" ")
        if (parts.length !== 2 || parts[0] !== "Bearer") {
            return res.status(401).json({ error: "Formato de token inv√°lido" })
        }
    
        const token = parts[1]
        if (!token) {
            return res.status(401).json({ error: "Token inv√°lido" })
        }
    
        const secret = process.env.JWT_SECRET
        if (!secret) {
            throw new Error("JWT_SECRET is not defined")
        }
    
        try {
            const decoded = jwt.verify(token, secret)
    
            if (!isAuthTokenPayload(decoded)) {
                return res.status(401).json({ error: "Token inv√°lido" })
            }
    
            req.user = {
                userId: decoded.userId,
                role: decoded.role,
            }
    
            next()
        } catch {
            return res.status(401).json({ error: "Token inv√°lido" })
        }
    }

============================================================
FILE: ./src/middlewares/isAdmin.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Request, Response, NextFunction } from "express"
    
    export const isAdmin = (
        req: Request,
        res: Response,
        next: NextFunction,
    ) => {
        if (!req.user) {
            return res.status(401).json({ error: "Usu√°rio n√£o autenticado" })
        }
    
        if (req.user.role !== "admin") {
            return res
                .status(403)
                .json({ error: "Acesso negado: apenas administradores" })
        }
    
        next()
    }

============================================================
FILE: ./src/routes/cartRoutes.ts
LAST_MODIFIED: 2025-12-28 17:10:55
============================================================

    import { Router } from "express"
    import { getCart, addItemToCart, removeItemFromCart, clearCart } from "../controllers/cartController"
    import { authenticate } from "../middlewares/authMiddleware" // Corrigido para plural
    
    const router = Router()
    
    router.get("/", authenticate, getCart)
    router.post("/add", authenticate, addItemToCart)
    router.post("/remove", authenticate, removeItemFromCart) // Corrigido nome da fun√ß√£o
    router.post("/clear", authenticate, clearCart)
    
    export default router
============================================================
FILE: ./src/routes/userRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware"
    import { isAdmin } from "../middlewares/isAdmin"
    import {
        getAllUsers,
        getUserById,
        updateUser,
        deleteUser,
    } from "../controllers/userController"
    
    const router = Router()
    
    // Todas as rotas de manipula√ß√£o de usu√°rios exigem Admin neste design
    router.get("/", authenticate, isAdmin, getAllUsers)
    router.get("/:id", authenticate, isAdmin, getUserById)
    router.put("/:id", authenticate, isAdmin, updateUser)
    router.delete("/:id", authenticate, isAdmin, deleteUser)
    
    export default router

============================================================
FILE: ./src/routes/authRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { registerUser, loginUser } from "../controllers/authController"
    
    const router = Router()
    
    router.post("/register", registerUser)
    router.post("/login", loginUser)
    
    export default router
============================================================
FILE: ./src/routes/adminRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware"
    import { isAdmin } from "../middlewares/isAdmin"
    import { getStats } from "../controllers/adminController"
    
    const router = Router()
    
    router.get("/stats", authenticate, isAdmin, getStats)
    
    export default router

============================================================
FILE: ./src/routes/orderRoutes.ts
LAST_MODIFIED: 2025-12-28 13:50:58
============================================================

    import { Router } from "express"
    import { checkout, getMyOrders, updateOrderStatus, getAllOrders, createOrder } from "../controllers/orderController"
    import { authenticate } from "../middlewares/authMiddleware"
    
    const router = Router()
    
    router.post("/checkout", authenticate, checkout)
    router.post("/", authenticate, createOrder)
    router.get("/my", authenticate, getMyOrders)
    
    router.get("/", authenticate, getAllOrders)
    router.put("/:id", authenticate, updateOrderStatus)
    
    export default router
============================================================
FILE: ./src/routes/addressRoutes.ts
LAST_MODIFIED: 2025-12-28 17:07:56
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware" 
    import { 
        createAddress, 
        getAddresses, 
        updateAddress, 
        deleteAddress 
    } from "../controllers/addressController"
    
    const router = Router()
    
    // Todas as rotas de endere√ßo s√£o protegidas por autentica√ß√£o
    router.use(authenticate)
    
    // POST /api/addresses - Criar endere√ßo
    router.post("/", createAddress)
    
    // GET /api/addresses - Listar endere√ßos
    router.get("/", getAddresses)
    
    // PUT /api/addresses/:id - Atualizar endere√ßo
    router.put("/:id", updateAddress)
    
    // DELETE /api/addresses/:id - Deletar endere√ßo
    router.delete("/:id", deleteAddress)
    
    export default router
============================================================
FILE: ./src/routes/productRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/routes/productRoutes.ts
    
    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware" 
    import { adminAuth } from "../middlewares/adminAuth" 
    import { 
        createProduct, 
        getAllProducts, 
        updateProduct, 
        deleteProduct 
    } from "../controllers/productController" // Importa a l√≥gica do controller
    
    const router = Router()
    
    // GET /api/products - Rota p√∫blica para listar todos os produtos
    router.get("/", getAllProducts)
    
    // Rotas protegidas (apenas Admin)
    // POST /api/products - Criar produto
    router.post("/", authenticate, adminAuth, createProduct)
    
    // PUT /api/products/:id - Atualizar produto
    router.put("/:id", authenticate, adminAuth, updateProduct)
    
    // DELETE /api/products/:id - Deletar produto
    router.delete("/:id", authenticate, adminAuth, deleteProduct)
    
    export default router
============================================================
FILE: ./tests/products.test.ts
LAST_MODIFIED: 2025-12-29 17:53:57
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { Product } from "../src/infra/models/Product"
    import { createTestUser, createTestProduct } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import "./setup"
    
    describe("Product Routes", () => {
    
        let adminToken: string
        let userToken: string
    
        // Dados para um novo produto de teste
        const newProductData = {
            name: "Laptop Gamer",
            description: "M√°quina poderosa para jogos.",
            price: 5000.00,
            stock: 5,
        }
    
        beforeEach(async () => {
    
            clearDatabase()
    
            const [user, admin] = await Promise.all([
                createTestUser("user", "main"),
                createTestUser("admin", "main"),
            ])
    
            adminToken = admin.token
            userToken = user.token
        })
    
        describe("GET /api/products", () => {
    
            it("deve listar todos os produtos (rota p√∫blica)", async () => {
                await createTestProduct()
                // Rota p√∫blica, n√£o requer token
                const response = await request(app).get("/api/products") 
    
                expect(response.status).toBe(200)
                expect(response.body).toBeInstanceOf(Array)
                // Deve encontrar o produto criado no beforeEach
                expect(response.body.length).toBeGreaterThanOrEqual(1)
            })
        })
    
        describe("POST /api/products (Admin)", () => {
    
            it("deve permitir que o ADMIN crie um novo produto (201)", async () => {
                const response = await request(app)
                    .post("/api/products")
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send(newProductData)
    
                expect(response.status).toBe(201)
                expect(response.body.product.name).toBe(newProductData.name)
                expect(response.body.product.price).toBe(newProductData.price)
    
                // Verifica se foi salvo no DB
                const dbProduct = await Product.findById(response.body.product._id)
                expect(dbProduct).not.toBeNull()
            })
    
            it("n√£o deve permitir que o USU√ÅRIO COMUM crie um produto (403)", async () => {
    
                const response = await request(app)
                    .post("/api/products")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send(newProductData)
    
                expect(response.status).toBe(403)
                expect(response.body.error).toContain("Requer permiss√£o de Administrador")
            })
    
            it("deve retornar 401 se n√£o houver token", async () => {
    
                const response = await request(app)
                    .post("/api/products")
                    .send(newProductData)
    
                expect(response.status).toBe(401)
            })
    
            it("deve falhar se dados obrigat√≥rios (name/price) estiverem faltando (400)", async () => {
                const response = await request(app)
                    .post("/api/products")
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ description: "s√≥ descri√ß√£o" }) // Faltando name e price
    
                expect(response.status).toBe(400)
                expect(response.body.error).toContain("obrigat√≥rios") // Mensagem do productController
            })
        })
    
        describe("PUT /api/products/:id", () => {
            it("deve atualizar produto como admin", async () => {
                const product = await createTestProduct()
    
                const response = await request(app)
                    .put(`/api/products/${product._id}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({
                        price: 299.99,
                    })
    
                expect(response.status).toBe(200)
                expect(response.body.product.price).toBe(299.99)
            })
        })
    
        describe("DELETE /api/products/:id", () => {
            it("deve deletar produto como admin", async () => {
                const product = await createTestProduct()
    
                const response = await request(app)
                    .delete(`/api/products/${product._id}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
            })
        })
    })

============================================================
FILE: ./tests/auth.test.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { createTestUser } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import "./setup"
    
    clearDatabase()
    
    describe("Auth Routes", () => {
        describe("POST /api/auth/register", () => {
            it("deve registrar um novo usu√°rio", async () => {
                const response = await request(app)
                    .post("/api/auth/register")
                    .send({
                        name: "Novo Usu√°rio",
                        email: "novo@example.com",
                        password: "123456",
                    })
    
                expect(response.status).toBe(201)
                expect(response.body).toHaveProperty("token")
                expect(response.body.user).toHaveProperty(
                    "email",
                    "novo@example.com",
                )
            })
    
            it("n√£o deve registrar usu√°rio com email duplicado", async () => {
                const { user } = await createTestUser()
    
                const response = await request(app)
                    .post("/api/auth/register")
                    .send({
                        name: "Hildebrando",
                        email: user.email,
                        password: "123456",
                    })
    
                expect(response.status).toBe(409)
            })
    
    
            it("deve fazer login com credenciais v√°lidas", async () => {
                const { user } = await createTestUser()
    
                const response = await request(app)
                    .post("/api/auth/login")
                    .send({
                        email: user.email,
                        password: "123456",
                    })
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveProperty("token")
            })
    
            it("n√£o deve fazer login com senha incorreta", async () => {
                await createTestUser()
    
                const response = await request(app).post("/api/auth/login").send({
                    email: "hildebrando@example.com",
                    password: "senha_errada",
                })
    
                expect(response.status).toBe(401)
            })
    
            it("n√£o deve fazer login com email inexistente", async () => {
                const response = await request(app).post("/api/auth/login").send({
                    email: "naoexiste@example.com",
                    password: "123456",
                })
    
                expect(response.status).toBe(401)
            })
        })
    })

============================================================
FILE: ./tests/address.test.ts
LAST_MODIFIED: 2025-12-29 17:03:41
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { createTestUser } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import { Address, IAddress } from "../src/infra/models/Address" // Certifique-se de importar IAddress se estiver usando TypeScript
    import "./setup" 
    
    describe("Address Routes", () => {
        let userToken: string = ""
        let userId: string = ""
        let anotherUserToken: string = ""
        let anotherUserId: string = ""
    
        // Data padr√£o para um endere√ßo
        const addressData = {
            street: "Rua Teste, 123",
            city: "Cidade Teste",
            state: "SP",
            zipCode: "12345-678",
            country: "Brasil",
        }
    
        beforeEach(async () => {
    
            clearDatabase()
            
            // Criar dois usu√°rios para testar isolamento de dados
            const [user, anotherUser] = await Promise.all([
                createTestUser("user", "main"), 
                createTestUser("user", "other"),
            ])
    
            userToken = user.token
            userId = user.user._id.toString()
            anotherUserToken = anotherUser.token
            anotherUserId = anotherUser.user._id.toString()
        })
    
        // Helper para criar um endere√ßo no DB diretamente
        const createAddressInDB = async (id: string, data: any): Promise<IAddress> => {
            const address = new Address({
                userId: id,
                ...data,
            })
            await address.save()
            return address as IAddress
        }
    
        // =================================================================
        // POST /api/addresses
        // =================================================================
        describe("POST /api/addresses", () => {
            it("deve criar um novo endere√ßo para o usu√°rio (201)", async () => {
                const response = await request(app)
                    .post("/api/addresses")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send(addressData)
    
                expect(response.status).toBe(201)
                expect(response.body.address.street).toBe(addressData.street)
                expect(response.body.address.userId.toString()).toBe(userId)
    
                const dbAddress = await Address.findById(response.body.address._id)
                expect(dbAddress).not.toBeNull()
            })
    
            it("deve falhar se dados obrigat√≥rios estiverem faltando (400)", async () => {
                const response = await request(app)
                    .post("/api/addresses")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ street: addressData.street }) // Faltando city, state, zipCode
    
                expect(response.status).toBe(400)
                expect(response.body.error).toContain("obrigat√≥rios")
            })
    
            it("deve falhar se n√£o houver token (401)", async () => {
                const response = await request(app)
                    .post("/api/addresses")
                    .send(addressData)
    
                expect(response.status).toBe(401)
            })
            
            it("deve definir como default e desativar o default anterior", async () => {
                // 1. Cria um endere√ßo padr√£o que deve ser desativado
                const initialDefault = await createAddressInDB(userId, { ...addressData, isDefault: true, street: "Default Antigo" })
    
                // 2. Cria um novo endere√ßo padr√£o (novo default)
                const response = await request(app)
                    .post("/api/addresses")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ ...addressData, isDefault: true, street: "Novo Default" })
    
                expect(response.status).toBe(201)
                expect(response.body.address.isDefault).toBe(true)
    
                // 3. Verifica no DB se o default antigo foi desativado
                const oldDefault = await Address.findById(initialDefault._id)
                expect(oldDefault?.isDefault).toBe(false)
            })
        })
    
        // =================================================================
        // GET /api/addresses
        // =================================================================
        describe("GET /api/addresses", () => {
            it("deve listar apenas endere√ßos do usu√°rio logado (200)", async () => {
                // Endere√ßo do usu√°rio logado
                const userAddress = await createAddressInDB(userId, addressData)
                // Endere√ßo de outro usu√°rio
                await createAddressInDB(anotherUserId, { ...addressData, street: "Rua Estranha" })
    
                const response = await request(app)
                    .get("/api/addresses")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveLength(1)
                expect(response.body[0].street).toBe(userAddress.street)
            })
    
            it("deve retornar array vazio se n√£o houver endere√ßos (200)", async () => {
                // Nenhuma cria√ß√£o de endere√ßo
                const response = await request(app)
                    .get("/api/addresses")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveLength(0)
            })
    
            it("deve falhar se n√£o houver token (401)", async () => {
                const response = await request(app)
                    .get("/api/addresses")
    
                expect(response.status).toBe(401)
            })
        })
        
        // =================================================================
        // PUT /api/addresses/:id
        // =================================================================
        describe("PUT /api/addresses/:id", () => {
            let address: IAddress
    
            beforeEach(async () => {
                address = await createAddressInDB(userId, addressData)
            })
    
            it("deve atualizar um endere√ßo existente (200)", async () => {
                const update = { street: "Nova Rua, 999", zipCode: "87654-321" }
                
                const response = await request(app)
                    .put(`/api/addresses/${address._id}`)
                    .set("Authorization", `Bearer ${userToken}`)
                    .send(update)
    
                expect(response.status).toBe(200)
                expect(response.body.address.street).toBe(update.street)
                expect(response.body.address.zipCode).toBe(update.zipCode)
                expect(response.body.address.city).toBe(address.city) // N√£o deve mudar
            })
    
            it("deve falhar ao atualizar endere√ßo de outro usu√°rio (404)", async () => {
                // Tenta atualizar o endere√ßo do user pelo anotherUser
                const response = await request(app)
                    .put(`/api/addresses/${address._id}`)
                    .set("Authorization", `Bearer ${anotherUserToken}`)
                    .send({ street: "Tentativa de Fraude" })
    
                expect(response.status).toBe(404)
                expect(response.body.error).toContain("n√£o pertence ao usu√°rio")
            })
    
            it("deve falhar se n√£o houver token (401)", async () => {
                const update = { street: "Nova Rua" }
                const response = await request(app)
                    .put(`/api/addresses/${address._id}`)
                    .send(update)
    
                expect(response.status).toBe(401)
            })
            
            it("deve tornar o endere√ßo padr√£o e desativar o anterior", async () => {
                // 1. Cria um segundo endere√ßo, define o primeiro como default
                await Address.findByIdAndUpdate(address._id, { isDefault: true })
                const secondAddress = await createAddressInDB(userId, { ...addressData, street: "Segundo Endere√ßo", isDefault: false })
                
                // 2. Atualiza o segundo endere√ßo para ser o default
                const response = await request(app)
                    .put(`/api/addresses/${secondAddress._id}`)
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ isDefault: true })
    
                expect(response.status).toBe(200)
                expect(response.body.address.isDefault).toBe(true)
    
                // 3. Verifica no DB se o default original foi desativado
                const oldDefault = await Address.findById(address._id)
                expect(oldDefault?.isDefault).toBe(false)
            })
        })
    
        // =================================================================
        // DELETE /api/addresses/:id
        // =================================================================
        describe("DELETE /api/addresses/:id", () => {
            let addressToDelete: IAddress
    
            beforeEach(async () => {
                addressToDelete = await createAddressInDB(userId, addressData)
            })
    
            it("deve deletar um endere√ßo existente (200)", async () => {
                const response = await request(app)
                    .delete(`/api/addresses/${addressToDelete._id}`)
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body.message).toContain("removido com sucesso")
    
                const dbAddress = await Address.findById(addressToDelete._id)
                expect(dbAddress).toBeNull()
            })
    
            it("deve falhar ao deletar endere√ßo de outro usu√°rio (404)", async () => {
                const response = await request(app)
                    .delete(`/api/addresses/${addressToDelete._id}`)
                    .set("Authorization", `Bearer ${anotherUserToken}`)
    
                expect(response.status).toBe(404)
                expect(response.body.error).toContain("n√£o pertence ao usu√°rio")
    
                // Verifica se o endere√ßo ainda est√° no DB
                const dbAddress = await Address.findById(addressToDelete._id)
                expect(dbAddress).not.toBeNull()
            })
    
            it("deve falhar se n√£o houver token (401)", async () => {
                const response = await request(app)
                    .delete(`/api/addresses/${addressToDelete._id}`)
    
                expect(response.status).toBe(401)
            })
        })
    })
============================================================
FILE: ./tests/helpers/clearDatabase.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose from "mongoose"
    
    export async function clearDatabase() {
    
        const collections = mongoose.connection.collections
    
        for (const key in collections) {
    
            await collections[key].deleteMany({})
        }
    }

============================================================
FILE: ./tests/helpers/testHelpers.ts
LAST_MODIFIED: 2025-12-29 17:29:55
============================================================

    import { User } from "../../src/infra/models/User"
    import { Product } from "../../src/infra/models/Product"
    import * as bcrypt from "bcrypt"
    import jwt from "jsonwebtoken"
    
    const JWT_SECRET = process.env.JWT_SECRET || "supersecret"
    
    export const createTestUser = async (role: "user" | "admin" = "user", suffix: string = Date.now().toString()): Promise<{ token: string }> => {
    
        const passwordHash = await bcrypt.hash("123456", 10)
        let email: string
        if (role === "admin") {
            email = `admin-${suffix}@example.com`
        } else {
            email = `user-${suffix}@example.com`
        }
    
        const user = await User.create({
            name: "Hildebrando",
            email,
            passwordHash,
            role,
        })
    
        const token = jwt.sign(
            {
                userId: user._id.toString(),
                role: user.role,
            },
            JWT_SECRET || "supersecret",
            { expiresIn: "1h" }
        )
    
        return { user, token }
    }
    
    export const createTestProduct = async (productData = {}) => {
        return await Product.create({
            name: "Produto Teste",
            description: "Descri√ß√£o do produto teste",
            price: 99.99,
            stock: 10,
            ...productData,
        })
    }
============================================================
FILE: ./tests/users.test.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { createTestUser } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import "./setup"
    
    describe("User Routes", () => {
        let adminToken: string
        let userToken: string
        let userId: string
    
        beforeEach(async () => {
    
            clearDatabase()
            const admin = await createTestUser("admin")
            const user = await createTestUser("user")
            adminToken = admin.token
            userToken = user.token
            userId = user.user._id.toString()
        })
    
        describe("GET /api/users", () => {
            it("deve listar usu√°rios como admin", async () => {
                const response = await request(app)
                    .get("/api/users")
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
                expect(Array.isArray(response.body)).toBe(true)
                expect(response.body.length).toBeGreaterThanOrEqual(2) // admin + user
            })
    
            it("n√£o deve retornar hash de senha", async () => {
                const response = await request(app)
                    .get("/api/users")
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body[0]).not.toHaveProperty("passwordHash")
            })
    
            it("n√£o deve listar usu√°rios sem ser admin", async () => {
                const response = await request(app)
                    .get("/api/users")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(403)
            })
    
            it("n√£o deve listar usu√°rios sem autentica√ß√£o", async () => {
                const response = await request(app).get("/api/users")
    
                expect(response.status).toBe(401)
            })
        })
    
        describe("GET /api/users/:id", () => {
            it("deve buscar usu√°rio por ID como admin", async () => {
                const response = await request(app)
                    .get(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveProperty("email")
                expect(response.body).toHaveProperty("name")
                expect(response.body).not.toHaveProperty("passwordHash")
            })
    
            it("deve retornar 404 para usu√°rio inexistente", async () => {
                const fakeId = "507f1f77bcf86cd799439011"
    
                const response = await request(app)
                    .get(`/api/users/${fakeId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(404)
            })
    
            it("n√£o deve buscar usu√°rio sem ser admin", async () => {
                const response = await request(app)
                    .get(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(403)
            })
    
            it("n√£o deve buscar usu√°rio sem autentica√ß√£o", async () => {
                const response = await request(app).get(`/api/users/${userId}`)
    
                expect(response.status).toBe(401)
            })
        })
    
        describe("PUT /api/users/:id", () => {
            it("deve atualizar usu√°rio como admin", async () => {
                const response = await request(app)
                    .put(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ name: "Nome Atualizado" })
    
                expect(response.status).toBe(200)
                expect(response.body.user.name).toBe("Nome Atualizado")
                expect(response.body.message).toBe("Usu√°rio atualizado com sucesso!")
            })
    
            it("n√£o deve retornar hash de senha ao atualizar", async () => {
                const response = await request(app)
                    .put(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ name: "Nome Atualizado" })
    
                expect(response.status).toBe(200)
                expect(response.body.user).not.toHaveProperty("passwordHash")
            })
    
            it("deve atualizar m√∫ltiplos campos", async () => {
                const response = await request(app)
                    .put(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({
                        name: "Novo Nome",
                        email: "novoemail@example.com",
                    })
    
                expect(response.status).toBe(200)
                expect(response.body.user.name).toBe("Novo Nome")
                expect(response.body.user.email).toBe("novoemail@example.com")
            })
    
            it("deve retornar 404 para usu√°rio inexistente", async () => {
                const fakeId = "507f1f77bcf86cd799439011"
    
                const response = await request(app)
                    .put(`/api/users/${fakeId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ name: "Nome" })
    
                expect(response.status).toBe(404)
            })
    
            it("n√£o deve atualizar usu√°rio sem ser admin", async () => {
                const response = await request(app)
                    .put(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ name: "Nome Atualizado" })
    
                expect(response.status).toBe(403)
            })
    
            it("n√£o deve atualizar usu√°rio sem autentica√ß√£o", async () => {
                const response = await request(app)
                    .put(`/api/users/${userId}`)
                    .send({ name: "Nome Atualizado" })
    
                expect(response.status).toBe(401)
            })
        })
    
        describe("DELETE /api/users/:id", () => {
            it("deve deletar usu√°rio como admin", async () => {
                const response = await request(app)
                    .delete(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body.message).toBe("Usu√°rio removido com sucesso!")
            })
    
            it("usu√°rio deletado n√£o deve mais existir", async () => {
                await request(app)
                    .delete(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                const response = await request(app)
                    .get(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(404)
            })
    
            it("deve retornar 404 para usu√°rio inexistente", async () => {
                const fakeId = "507f1f77bcf86cd799439011"
    
                const response = await request(app)
                    .delete(`/api/users/${fakeId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(404)
            })
    
            it("n√£o deve deletar usu√°rio sem ser admin", async () => {
                const response = await request(app)
                    .delete(`/api/users/${userId}`)
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(403)
            })
    
            it("n√£o deve deletar usu√°rio sem autentica√ß√£o", async () => {
                const response = await request(app).delete(`/api/users/${userId}`)
    
                expect(response.status).toBe(401)
            })
        })
    })
============================================================
FILE: ./tests/integration/checkout-outbox.integration.spec.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import mongoose from "mongoose"
    import { MongoMemoryServer } from "mongodb-memory-server"
    
    import { makeCheckoutUseCase } from "../../src/infra/factories/checkoutFactory"
    import { MongoOutboxDispatcher } from "../../src/infra/outbox/MongoOutboxDispatcher"
    
    import { Cart } from "../../src/infra/models/Cart"
    import { Product } from "../../src/infra/models/Product"
    import { Outbox } from "../../src/infra/models/Outbox"
    
    let mongo: MongoMemoryServer
    
    beforeAll(async () => {
        mongo = await MongoMemoryServer.create()
    
        if (mongoose.connection.readyState === 0) {
            await mongoose.connect(mongo.getUri())
        }
    })
    
    afterAll(async () => {
        await mongoose.disconnect()
        await mongo.stop()
    })
    
    afterEach(async () => {
        await mongoose.connection.db.dropDatabase()
    })
    
    describe("Checkout + Outbox integration", () => {
    
        it("should persist outbox event and dispatch it correctly", async () => {
    
            // Arrange
            const userId = new mongoose.Types.ObjectId()
            const productId = new mongoose.Types.ObjectId()
    
            await Product.create({
                _id: productId,
                name: "Notebook",
                price: 3000,
                stock: 10,
            })
    
            await Cart.create({
                userId,
                items: [
                    {
                        productId,
                        quantity: 1,
                    },
                ],
            })
    
            const checkoutUseCase = makeCheckoutUseCase()
    
            // Act ‚Äî executar checkout
            const result = await checkoutUseCase.execute({ userId })
    
            // Assert ‚Äî pedido criado
            expect(result.orderId).toBeDefined()
            expect(result.total).toBe(3000)
            expect(result.status).toBe("pending")
    
            // Assert ‚Äî evento salvo no Outbox
            const eventsBefore = await Outbox.find()
    
            expect(eventsBefore).toHaveLength(1)
            expect(eventsBefore[0].name).toBe("order.placed")
            expect(eventsBefore[0].processed).toBe(false)
    
            // Act ‚Äî dispatcher
            const dispatcher = new MongoOutboxDispatcher()
            await dispatcher.dispatch()
    
            // Assert ‚Äî evento processado
            const eventAfter = await Outbox.findById(eventsBefore[0]._id)
    
            expect(eventAfter?.processed).toBe(true)
            expect(eventAfter?.processedAt).toBeDefined()
        })
    
    })

============================================================
FILE: ./tests/admin.test.ts
LAST_MODIFIED: 2025-12-22 20:35:24
============================================================

    import request from "supertest"
    import mongoose from "mongoose"
    import app from "../src/app"
    import { createTestUser, createTestProduct } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import { Order } from "../src/infra/models/Order"
    import { Cart } from "../src/infra/models/Cart"
    import "./setup"
    
    describe("Admin Routes", () => {
        let adminToken: string
        let userToken: string
        let product1: any
    
        beforeEach(async () => {
    
            clearDatabase()
            const admin = await createTestUser("admin")
            const user = await createTestUser("user")
            adminToken = admin.token
            userToken = user.token
            product1 = await createTestProduct({ price: 100 }) // Produto base para pedidos
        })
    
        describe("GET /api/admin/stats", () => {
            it("deve retornar estat√≠sticas completas para o admin", async () => {
                // Setup: Criar dados para popular as estat√≠sticas
    
                // 1. Produtos (product1 j√° existe do beforeEach)
                await createTestProduct({ price: 50 })
    
                // 2. Pedido
                const order = new Order({
                    userId: new mongoose.Types.ObjectId(),
                    items: [{ productId: product1._id, quantity: 2 }],
                    total: 200,
                    status: "completed",
                })
                await order.save()
    
                // 3. Carrinho
                const cart = new Cart({
                    userId: new mongoose.Types.ObjectId(),
                    items: [{ productId: product1._id, quantity: 1 }],
                })
                await cart.save()
    
                const response = await request(app)
                    .get("/api/admin/stats")
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
    
                // Verifica√ß√µes de estrutura e valores
                expect(response.body).toHaveProperty("users")
                // Admin (1) + User (1) no beforeEach = 2
                expect(response.body.users.total).toBeGreaterThanOrEqual(2)
    
                expect(response.body).toHaveProperty("products")
                // product1 + product2 no setup = 2
                expect(response.body.products.total).toBe(2)
    
                expect(response.body).toHaveProperty("orders")
                expect(response.body.orders.total).toBe(1)
                expect(response.body.orders.revenueTotal).toBe(200)
    
                expect(response.body).toHaveProperty("carts")
                expect(response.body.carts.avgItems).toBe(1)
            })
    
            it("deve filtrar estat√≠sticas por intervalo de datas", async () => {
                // Setup: Data de Hoje (usaremos 2025-12-15 como base)
                const TODAY = new Date("2025-12-15T12:00:00.000Z")
    
                // Pedido A: DENTRO do per√≠odo de filtro (Total 100, Status: paid)
                const orderA = new Order({
                    userId: new mongoose.Types.ObjectId(),
                    items: [{ productId: product1._id, quantity: 1 }],
                    total: 100,
                    status: "paid",
                    createdAt: TODAY, // Hoje
                })
                await orderA.save()
    
                // Pedido B: FORA do per√≠odo de filtro (Total 500, Status: completed)
                const YESTERDAY = new Date("2025-12-14T12:00:00.000Z") // Ontem
                const orderB = new Order({
                    userId: new mongoose.Types.ObjectId(),
                    items: [{ productId: product1._id, quantity: 5 }],
                    total: 500,
                    status: "completed",
                    createdAt: YESTERDAY,
                })
                await orderB.save()
    
                // DEFINIR O FILTRO: Apenas para "Hoje"
                const filterStart = "2025-12-15T00:00:00.000Z"
                const filterEnd = "2025-12-15T23:59:59.999Z"
    
                const response = await request(app)
                    .get(
                        `/api/admin/stats?startDate=${filterStart}&endDate=${filterEnd}`,
                    )
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
    
                // Deve contar APENAS o Pedido A
                expect(response.body.orders.total).toBe(1)
                expect(response.body.orders.revenueTotal).toBe(100)
    
                // O status 'completed' do Pedido B n√£o deve aparecer
                const paidStatus = response.body.orders.byStatus.find(
                    (s: any) => s._id === "paid",
                )
                const completedStatus = response.body.orders.byStatus.find(
                    (s: any) => s._id === "completed",
                )
    
                expect(paidStatus?.count).toBe(1)
                expect(completedStatus).toBeUndefined() // Verifica se o pedido de ontem foi exclu√≠do
            })
    
            it("n√£o deve permitir acesso a usu√°rio comum", async () => {
                const response = await request(app)
                    .get("/api/admin/stats")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(403)
            })
    
            it("n√£o deve permitir acesso sem autentica√ß√£o", async () => {
                const response = await request(app).get("/api/admin/stats")
    
                expect(response.status).toBe(401)
            })
        })
    })

============================================================
FILE: ./tests/cart.test.ts
LAST_MODIFIED: 2025-12-29 17:23:11
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { clearDatabase } from "./helpers/clearDatabase"
    import { createTestUser, createTestProduct } from "./helpers/testHelpers"
    import "./setup"
    
    clearDatabase()
    
    describe("Cart Routes", () => {
        let userToken: string
        let productId: string
    
        beforeEach(async () => {
            const user = await createTestUser("user")
            userToken = user.token
    
            const product = await createTestProduct()
            productId = product._id.toString()
        })
    
        describe("GET /api/cart", () => {
            it("deve retornar carrinho vazio para novo usu√°rio", async () => {
                const response = await request(app)
                    .get("/api/cart")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body.items || []).toHaveLength(0)
            })
    
            it("n√£o deve acessar carrinho sem autentica√ß√£o", async () => {
                const response = await request(app).get("/api/cart")
    
                expect(response.status).toBe(401)
            })
        })
    
        describe("POST /api/cart/add", () => {
            it("deve adicionar item ao carrinho", async () => {
                const response = await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({
                        productId,
                        quantity: 2,
                    })
    
                expect(response.status).toBe(200)
                expect(response.body.cart.items).toHaveLength(1)
                expect(response.body.cart.items[0].quantity).toBe(2)
            })
    
            it("deve incrementar quantidade se produto j√° existe", async () => {
                // Adiciona pela primeira vez
                await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId, quantity: 2 })
    
                // Adiciona novamente
                const response = await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId, quantity: 3 })
    
                expect(response.status).toBe(200)
                expect(response.body.cart.items).toHaveLength(1)
                expect(response.body.cart.items[0].quantity).toBe(5)
            })
    
            it("n√£o deve adicionar sem autentica√ß√£o", async () => {
                const response = await request(app)
                    .post("/api/cart/add")
                    .send({ productId, quantity: 2 })
    
                expect(response.status).toBe(401)
            })
    
            it("n√£o deve adicionar item sem productId ou quantity", async () => {
                const response = await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId, quantity: undefined }) // Falta quantity (ou productId)
    
                // Esperar 400 se o controlador for implementado para validar o payload
                // Atualmente o controller falharia com 500 ou erro de Mongoose, mas 400 √© o correto.
                expect(response.status).toBe(400)
            })
    
            it("n√£o deve adicionar produto que n√£o existe", async () => {
                // ID inexistente (v√°lido no formato Mongoose, mas n√£o no DB)
                const fakeProductId = "507f1f77bcf86cd799439011"
    
                const response = await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId: fakeProductId, quantity: 1 })
    
                // Se o controlador for corrigido para validar o Product ID no DB antes de adicionar.
                expect(response.status).toBe(404)
            })
        })
    
        describe("POST /api/cart/remove", () => {
            it("deve remover item do carrinho", async () => {
                // Adiciona item
                await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId, quantity: 2 })
    
                // Remove item
                const response = await request(app)
                    .post("/api/cart/remove")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId })
    
                expect(response.status).toBe(200)
                expect(response.body.cart.items).toHaveLength(0)
            })
    
            it("deve retornar 404 se carrinho n√£o existe", async () => {
                const response = await request(app)
                    .post("/api/cart/remove")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId })
    
                expect(response.status).toBe(404)
            })
        })
    
        describe("POST /api/cart/clear", () => {
            it("deve limpar carrinho", async () => {
                // Adiciona itens
                await request(app)
                    .post("/api/cart/add")
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ productId, quantity: 2 })
    
                // Limpa carrinho
                const response = await request(app)
                    .post("/api/cart/clear")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body.cart.items).toHaveLength(0)
            })
    
            it("deve retornar 404 se carrinho n√£o existe", async () => {
                const response = await request(app)
                    .post("/api/cart/clear")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(404)
            })
        })
    })

============================================================
FILE: ./tests/setup.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import mongoose from "mongoose"
    import { MongoMemoryReplSet } from "mongodb-memory-server"
    import * as dotenv from "dotenv"
    
    dotenv.config()
    process.env.JWT_SECRET = process.env.JWT_SECRET || "test-jwt-secret"
    
    let replset: MongoMemoryReplSet
    
    beforeAll(async () => {
    
        replset = await MongoMemoryReplSet.create({
    
            replSet: { count: 1 },
        })
    
        const uri = replset.getUri()
        await mongoose.connect(uri)
    })
    
    afterAll(async () => {
    
        await mongoose.disconnect()
        await replset.stop()
    })

============================================================
FILE: ./tests/order.test.ts
LAST_MODIFIED: 2025-12-29 17:46:00
============================================================

    import request from "supertest"
    import app from "../src/app"
    import { createTestUser } from "./helpers/testHelpers"
    import { clearDatabase } from "./helpers/clearDatabase"
    import mongoose from "mongoose"
    import { Cart } from "../src/infra/models/Cart"
    import { Order } from "../src/infra/models/Order"
    import { Product } from "../src/infra/models/Product" 
    import "./setup" 
    
    describe("Order Routes", () => {
    
        // Inicializar vari√°veis com strings vazias para evitar ReferenceError caso o beforeEach falhe
        let userToken: string = "" 
        let adminToken: string = ""
        let userId: string = ""
        
        // Configura√ß√£o robusta e paralela
        beforeEach(async () => {
    
            clearDatabase()
            // Cria usu√°rios e um produto base de forma eficiente
            const [user, admin] = await Promise.all([
                createTestUser("user"),
                createTestUser("admin"),
            ])
    
            userToken = user.token
            userId = user.user._id.toString()
            adminToken = admin.token
        })
    
        // --- POST /api/orders/checkout ---
        describe("POST /api/orders/checkout", () => {
    
            it("deve criar um pedido com sucesso quando o estoque for suficiente", async () => {
                const { user, token } = await createTestUser()
    
                const product = await Product.create({
                    name: "Produto Teste",
                    price: 100,
                    stock: 10,
                })
    
                await Cart.create({
                    userId: user._id,
                    items: [
                        {
                            productId: product._id,
                            quantity: 2,
                        },
                    ],
                })
    
                const response = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${token}`)
    
                expect(response.status).toBe(201)
                expect(response.body).toHaveProperty("order")
                expect(response.body.order.total).toBe(200)
    
                const productAfter = await Product.findById(product._id)
                expect(productAfter!.stock).toBe(8)
    
                const cartAfter = await Cart.findOne({ userId: user._id })
                expect(cartAfter!.items.length).toBe(0)
            })
    
            it("n√£o deve criar pedido se o carrinho estiver vazio", async () => {
                const { user, token } = await createTestUser()
    
                await Cart.create({
                    userId: user._id,
                    items: [],
                })
    
                const response = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${token}`)
    
                expect(response.status).toBe(400)
                expect(response.body.error).toContain("Carrinho vazio")
            })
    
            it("n√£o deve criar pedido se algum produto n√£o existir", async () => {
                const { user, token } = await createTestUser()
    
                const fakeProductId = new mongoose.Types.ObjectId()
    
                await Cart.create({
                    userId: user._id,
                    items: [
                        {
                            productId: fakeProductId,
                            quantity: 1,
                        },
                    ],
                })
    
                const response = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${token}`)
    
                expect(response.status).toBe(400)
                expect(response.body.error).toContain("Produto")
                expect(response.body.error).toContain("n√£o encontrado")
            })
    
            it("n√£o deve criar pedido se o estoque for insuficiente", async () => {
                const { user, token } = await createTestUser()
    
                const product = await Product.create({
                    name: "Produto com Estoque Baixo",
                    price: 50,
                    stock: 1,
                })
    
                await Cart.create({
                    userId: user._id,
                    items: [
                        {
                            productId: product._id,
                            quantity: 5, // maior que o estoque
                        },
                    ],
                })
    
                const response = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${token}`)
    
                expect(response.status).toBe(400)
                expect(response.body.error).toContain("Estoque insuficiente")
    
                // garante que o estoque N√ÉO foi alterado
                const productAfterFailure = await Product.findById(product._id)
                expect(productAfterFailure!.stock).toBe(1)
    
                // garante que o pedido N√ÉO foi criado
                const orders = await Order.find({ userId: user._id })
                expect(orders.length).toBe(0)
            })
    
        })
    
    
        // --- GET /api/orders/my ---
        describe("GET /api/orders/my", () => {
            it("deve listar apenas os pedidos do usu√°rio logado", async () => {
                // Cria um pedido para este usu√°rio
                const myOrder = new Order({
                    userId,
                    items: [],
                    total: 100,
                    status: "pending",
                })
                await myOrder.save()
    
                // Cria um pedido para outro usu√°rio
                await new Order({
                    userId: new mongoose.Types.ObjectId(),
                    items: [],
                    total: 50,
                    status: "completed",
                }).save()
    
                const response = await request(app)
                    .get("/api/orders/my")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveLength(1)
                expect(response.body[0]._id).toBe(myOrder._id.toString())
            })
        })
    
        // --- GET /api/orders (Admin) ---
        describe("GET /api/orders (Admin)", () => {
            it("deve listar todos os pedidos se for admin", async () => {
                await new Order({ userId, items: [], total: 100 }).save()
                await new Order({
                    userId: new mongoose.Types.ObjectId(),
                    items: [],
                    total: 200,
                }).save()
    
                const response = await request(app)
                    .get("/api/orders")
                    .set("Authorization", `Bearer ${adminToken}`)
    
                expect(response.status).toBe(200)
                expect(response.body).toHaveLength(2)
            })
    
            it("n√£o deve permitir acesso a usu√°rio comum", async () => {
                const response = await request(app)
                    .get("/api/orders")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(response.status).toBe(403)
            })
    
            // --- PUT /api/orders/:id ---
            it("deve atualizar o status do pedido como admin", async () => {
     
                const { user, token: userToken } = await createTestUser()
                const { token: adminToken } = await createTestUser("admin")
    
                const product = await Product.create({
                    name: "Produto Teste",
                    price: 100,
                    stock: 10,
                })
    
                await Cart.create({
                    userId: user._id,
                    items: [
                        {
                            productId: product._id,
                            quantity: 1,
                        },
                    ],
                })
    
                // checkout como user
                const checkoutResponse = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(checkoutResponse.status).toBe(201)
    
                const orderId = checkoutResponse.body.order._id
    
                // üîπ admin marca como pago
                const paidResponse = await request(app)
                    .put(`/api/orders/${orderId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ status: "paid" })
    
                expect(paidResponse.status).toBe(200)
                expect(paidResponse.body.status).toBe("paid")
    
                // üîπ admin envia
                const shippedResponse = await request(app)
                    .put(`/api/orders/${orderId}`)
                    .set("Authorization", `Bearer ${adminToken}`)
                    .send({ status: "shipped" })
    
                expect(shippedResponse.status).toBe(200)
                expect(shippedResponse.body.status).toBe("shipped")
            })
    
            it("n√£o deve permitir que usu√°rio comum atualize status", async () => {
                const { user, token: userToken } = await createTestUser()
    
                const product = await Product.create({
                    name: "Produto Teste",
                    price: 100,
                    stock: 10,
                })
    
                await Cart.create({
                    userId: user._id,
                    items: [
                        {
                            productId: product._id,
                            quantity: 1,
                        },
                    ],
                })
    
                // pedido nasce via checkout (como user)
                const checkoutResponse = await request(app)
                    .post("/api/orders/checkout")
                    .set("Authorization", `Bearer ${userToken}`)
    
                expect(checkoutResponse.status).toBe(201)
    
                const orderId = checkoutResponse.body.order._id
    
                // tentativa de update como usu√°rio comum
                const response = await request(app)
                    .put(`/api/orders/${orderId}`)
                    .set("Authorization", `Bearer ${userToken}`)
                    .send({ status: "shipped" })
    
                expect(response.status).toBe(403)
            })
    
        })
    })
